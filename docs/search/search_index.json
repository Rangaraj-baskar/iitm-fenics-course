{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction to FEniCS This is a five-day course focused on solving partial differential equations (PDEs) using the FEniCS software package. The goal is to introduce the students to PDEs encountered in various engineering and science disciplines, such as solid mechanics, heat transfer, and mass transport. The course materials, including tutorials and exercises, were created as part of a five-day workshop at IIT Madras, in collaboration with Vanderbilt University, USA. These materials are presented in Jupyter Notebooks , which allow you to see both the code and its explanations, as well as the results, all together. The tutorials are comprehensive notebooks that demonstrate how to approach different types of problems using FEniCS. On the other hand, the exercises are meant to be interactive, and they encourage you to expand the notebooks by adding new functionalities. This way, you can develop your expertise in using FEniCS. What is FEniCS? FEniCS is a high-performance computing (HPC) capable tool that efficiently utilizes supercomputers and high-performance clusters to solve complex scientific problems. It supports parallel computing, JIT compilation, and integrates with PETSc and MPI for scalability and performance. Its HPC capabilities enable researchers to perform large-scale simulations and analyses effectively. FEniCS is an acronym FEniCS is an acronym that stands for \"Finite Element Computational Software.\" The inclusion of \"ni\" in the name is to create a balanced and appealing composition. The FEniCS software package was compiled at the University of Chicago, whose Phoenix mascot likely influenced the choice of the name. Authors Abhinav Gupta Ravindra Duddu","title":"Home"},{"location":"#introduction-to-fenics","text":"This is a five-day course focused on solving partial differential equations (PDEs) using the FEniCS software package. The goal is to introduce the students to PDEs encountered in various engineering and science disciplines, such as solid mechanics, heat transfer, and mass transport. The course materials, including tutorials and exercises, were created as part of a five-day workshop at IIT Madras, in collaboration with Vanderbilt University, USA. These materials are presented in Jupyter Notebooks , which allow you to see both the code and its explanations, as well as the results, all together. The tutorials are comprehensive notebooks that demonstrate how to approach different types of problems using FEniCS. On the other hand, the exercises are meant to be interactive, and they encourage you to expand the notebooks by adding new functionalities. This way, you can develop your expertise in using FEniCS.","title":"Introduction to FEniCS"},{"location":"#what-is-fenics","text":"FEniCS is a high-performance computing (HPC) capable tool that efficiently utilizes supercomputers and high-performance clusters to solve complex scientific problems. It supports parallel computing, JIT compilation, and integrates with PETSc and MPI for scalability and performance. Its HPC capabilities enable researchers to perform large-scale simulations and analyses effectively. FEniCS is an acronym FEniCS is an acronym that stands for \"Finite Element Computational Software.\" The inclusion of \"ni\" in the name is to create a balanced and appealing composition. The FEniCS software package was compiled at the University of Chicago, whose Phoenix mascot likely influenced the choice of the name.","title":"What is FEniCS?"},{"location":"#authors","text":"Abhinav Gupta Ravindra Duddu","title":"Authors"},{"location":"1_introduction/1_motivation/","text":"","title":"Motivation"},{"location":"1_introduction/2_installation/","text":"Prerequisites To follow along with the examples, you need to install docker on your system. You need Windows 10/11 Education or Professional for this to work. This does not work on Windows 10/11 Home. Docker Paraview CMDER (Only for Windows) (After installation, open cmder and then go to Settings(Win+Alt+P)\u27a1import and choose the cmlab.xml provided in the repository.) Google Chrome (After installation, open Chrome and paste the following in the address bar, chrome://flags/. In the flags screen, enable WebGL Developer Extensions ) Install FEniCS Once the docker system is installed and running, open CMDER/terminal and run: docker pull iitrabhi/fenics_notebook Running To start the notebook server, use the following: docker run -p 8888:8888 -v host_system_path:/root/ -w /root/ iitrabhi/fenics_notebook Note: you should replace the variable host_system_path with the path of the folder that contains your code. e.g., If D:\\Codes contains your code, then to start the command line interface, you have to run: docker run -p 8888:8888 -v D:\\Codes:/root/ -w /root/ iitrabhi/fenics_notebook Once you run the above command in cmder, you will get a URL starting with http://127.0.0.1:8888/lab . Press Control and click on the URL to open a new Jupyter Notebook. If you have Windows home You can use google collab to run FEniCS on the cloud. Open Collab , upload your notebook and paste the following in the first cell of your notebook. try: import dolfin except ImportError: !wget \"https://fem-on-colab.github.io/releases/fenics-install.sh\" -O \"/tmp/fenics-install.sh\" && bash \"/tmp/fenics-install.sh\" import dolfin https://fem-on-colab.github.io/packages.html","title":"Installation"},{"location":"1_introduction/2_installation/#prerequisites","text":"To follow along with the examples, you need to install docker on your system. You need Windows 10/11 Education or Professional for this to work. This does not work on Windows 10/11 Home. Docker Paraview CMDER (Only for Windows) (After installation, open cmder and then go to Settings(Win+Alt+P)\u27a1import and choose the cmlab.xml provided in the repository.) Google Chrome (After installation, open Chrome and paste the following in the address bar, chrome://flags/. In the flags screen, enable WebGL Developer Extensions )","title":"Prerequisites"},{"location":"1_introduction/2_installation/#install-fenics","text":"Once the docker system is installed and running, open CMDER/terminal and run: docker pull iitrabhi/fenics_notebook","title":"Install FEniCS"},{"location":"1_introduction/2_installation/#running","text":"To start the notebook server, use the following: docker run -p 8888:8888 -v host_system_path:/root/ -w /root/ iitrabhi/fenics_notebook Note: you should replace the variable host_system_path with the path of the folder that contains your code. e.g., If D:\\Codes contains your code, then to start the command line interface, you have to run: docker run -p 8888:8888 -v D:\\Codes:/root/ -w /root/ iitrabhi/fenics_notebook Once you run the above command in cmder, you will get a URL starting with http://127.0.0.1:8888/lab . Press Control and click on the URL to open a new Jupyter Notebook.","title":"Running"},{"location":"1_introduction/2_installation/#if-you-have-windows-home","text":"You can use google collab to run FEniCS on the cloud. Open Collab , upload your notebook and paste the following in the first cell of your notebook. try: import dolfin except ImportError: !wget \"https://fem-on-colab.github.io/releases/fenics-install.sh\" -O \"/tmp/fenics-install.sh\" && bash \"/tmp/fenics-install.sh\" import dolfin https://fem-on-colab.github.io/packages.html","title":"If you have Windows home"},{"location":"1_introduction/3_quickstart/","text":"","title":"Quickstart"},{"location":"1_introduction/4_faq/","text":"Where to find help When in doubt about any specific FEniCS command or implementation, there are several resources you can refer to for clarification and assistance: FEniCS Book: The official FEniCS book is an invaluable resource. It provides comprehensive documentation, tutorials, examples, and detailed explanations of all FEniCS functionalities. You can find it at: The FEniCS Book FEniCS Q&A Forum: The FEniCS Q&A forum is an active community where users and developers discuss issues, ask questions, and share knowledge about FEniCS. You can post your questions here and get help from experienced FEniCS users and developers. Access the forum at FEniCS discourse FEniCS Workshop Slack channel: You can also join the FEniCS workshop community on Slack to connect with other users, developers, and experts in the field. Slack is an excellent platform for real-time discussions, sharing knowledge, and getting help with FEniCS-related topics. You can join the Slack community by using this link . FEniCS online documentation: The online documentation since V1.3.0 is available at this link . You can go into the python folder of any version to find the syntax and meaning of different commands. The latest version is not that descriptive, and thus I recommend checking out older documentation, as most of the commands are the same. Note: Please go through the official community page here . Books to read Bleyer, Jeremy. \u201cNumerical Tours of Continuum Mechanics Using FEniCS,\u201d n.d., 105. Langtangen, Hans Petter, and Anders Logg. \u201cSolving PDEs in Python \u2013 The FEniCS Tutorial Volume I,\u201d n.d., 153. Langtangen, Hans Petter, and Kent-Andre Mardal. \u201cIntroduction to Numerical Methods for Variational Problems\u201d. Vol. 21. Texts in Computational Science and Engineering. Cham: Springer International Publishing, 2019. https://doi.org/10.1007/978-3-030-23788-2. Logg, Anders, Kent-Andre Mardal, and Garth Wells, eds. \u201cAutomated Solution of Differential Equations by the Finite Element Method\u201d. Vol. 84. Lecture Notes in Computational Science and Engineering. Berlin, Heidelberg: Springer Berlin Heidelberg, 2012. https://doi.org/10.1007/978-3-642-23099-8.","title":"FAQ's"},{"location":"1_introduction/4_faq/#where-to-find-help","text":"When in doubt about any specific FEniCS command or implementation, there are several resources you can refer to for clarification and assistance: FEniCS Book: The official FEniCS book is an invaluable resource. It provides comprehensive documentation, tutorials, examples, and detailed explanations of all FEniCS functionalities. You can find it at: The FEniCS Book FEniCS Q&A Forum: The FEniCS Q&A forum is an active community where users and developers discuss issues, ask questions, and share knowledge about FEniCS. You can post your questions here and get help from experienced FEniCS users and developers. Access the forum at FEniCS discourse FEniCS Workshop Slack channel: You can also join the FEniCS workshop community on Slack to connect with other users, developers, and experts in the field. Slack is an excellent platform for real-time discussions, sharing knowledge, and getting help with FEniCS-related topics. You can join the Slack community by using this link . FEniCS online documentation: The online documentation since V1.3.0 is available at this link . You can go into the python folder of any version to find the syntax and meaning of different commands. The latest version is not that descriptive, and thus I recommend checking out older documentation, as most of the commands are the same. Note: Please go through the official community page here .","title":"Where to find help"},{"location":"1_introduction/4_faq/#books-to-read","text":"Bleyer, Jeremy. \u201cNumerical Tours of Continuum Mechanics Using FEniCS,\u201d n.d., 105. Langtangen, Hans Petter, and Anders Logg. \u201cSolving PDEs in Python \u2013 The FEniCS Tutorial Volume I,\u201d n.d., 153. Langtangen, Hans Petter, and Kent-Andre Mardal. \u201cIntroduction to Numerical Methods for Variational Problems\u201d. Vol. 21. Texts in Computational Science and Engineering. Cham: Springer International Publishing, 2019. https://doi.org/10.1007/978-3-030-23788-2. Logg, Anders, Kent-Andre Mardal, and Garth Wells, eds. \u201cAutomated Solution of Differential Equations by the Finite Element Method\u201d. Vol. 84. Lecture Notes in Computational Science and Engineering. Berlin, Heidelberg: Springer Berlin Heidelberg, 2012. https://doi.org/10.1007/978-3-642-23099-8.","title":"Books to read"},{"location":"2_tutorials/1_linear_poisson/","text":"Poissons Equation Welcome to this FEniCS tutorial, where we will explore how to verify the accuracy of a Poisson's equation solver using the \"manufactured solution\" technique. FEniCS is a powerful open-source finite element library for solving partial differential equations (PDEs), widely used for scientific computing and simulation. The \"manufactured solution\" approach is a valuable method to validate the correctness of finite element implementations. In this technique, we first construct an exact solution to the PDE, often a smooth and analytically known function, that satisfies the given equation. Next, we compute the corresponding right-hand side of the PDE using the exact solution. By feeding the manufactured solution and the derived right-hand side into our FEniCS solver, we can compare the numerical solution with the exact solution, thus quantifying the solver's accuracy. In this tutorial, we will focus on solving the one-dimensional Poisson's equation: \\[\\begin{split}- \\nabla^{2} u &= f \\quad {\\rm in} \\ \\Omega, \\\\ u &= 0 \\quad {\\rm on} \\ \\Gamma_{D}, \\\\ \\nabla u \\cdot n &= g \\quad {\\rm on} \\ \\Gamma_{N}. \\\\\\end{split} \\] subject to homogeneous Dirichlet boundary conditions, where u(x) is the unknown function, and f(x) is the right-hand side. We will construct a simple manufactured solution, u_exact(x), and calculate the corresponding f(x) that satisfies the equation. Throughout the tutorial, we will cover the following steps: Importing the necessary modules. Defining the manufactured solution and its corresponding right-hand side. Creating the one-dimensional mesh using FEniCS. Defining the appropriate FunctionSpace for the problem. Imposing the homogeneous Dirichlet boundary conditions. Formulating the variational problem using FEniCS's TrialFunction and TestFunction. Solving the Poisson's equation using FEniCS's solve function. Comparing the numerical solution with the exact solution to quantify the solver's accuracy. By the end of this tutorial, you will have a better understanding of the manufactured solution technique, its importance in validating finite element solvers, and how to implement it using FEniCS on an interval mesh. So, let's get started with our journey into the world - of FEniCS and manufactured solutions! Step 1: Import the necessary modules from dolfin import * import numpy as np import matplotlib.pyplot as plt % matplotlib inline Step 2: Define the mesh # Create the mesh num_elements = 3 # num_elements equally spaced intervals in [0, 1] mesh = IntervalMesh ( num_elements , 0 , 1 ) plot ( mesh ) [<matplotlib.lines.Line2D at 0x7f9f10e6d4e0>] Step 3: Define the function space The line of code U = FunctionSpace(mesh, \"CG\", 1) in FEniCS creates a function space U based on linear continuous elements ( CG ) defined on the mesh with degree 1 polynomial approximation. U = FunctionSpace ( mesh , \"CG\" , 1 ) Step 4: Define boundary condition We create a DirichletBC object ( bc ) that associates the function space U with the boundary condition u_D and the subdomain boundary . This means that the solution function u_sol will have the value 0.0 on the boundary of the domain during the solution of the PDE . u_D = Constant ( 0.0 ) boundary = CompiledSubDomain ( \"on_boundary\" ) bc = DirichletBC ( U , u_D , boundary ) Step 5: Define weak form \\[a(u, v) = L(v) \\quad \\forall \\ v \\in V,$$ $$\\begin{split}a(u, v) &= \\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, {\\rm d} x, \\\\ L(v) &= \\int_{\\Omega} f v \\, {\\rm d} x.\\end{split}\\] u = TrialFunction ( U ) v = TestFunction ( U ) a = inner ( grad ( u ), grad ( v )) * dx Step 5.1: Define the manufactured rhs For this tutorial, let's choose a simple manufactured solution. We will solve the Poisson's equation in 1D: \\[-\\Delta u(x) = f(x), 0 < x < 1,\\] where u(x) is the unknown function, and f(x) is the right-hand side. We will choose an analytical solution u_exact(x) that satisfies the above equation. For this example, let's take: \\[u_{exact}(x) = sin(\\pi x)\\] and calculate the corresponding f(x): \\[f(x) = -\\Delta u_{exact}(x) = \\pi^2 sin(\\pi x)\\] f_expr = Expression ( \"pi*pi*sin(pi*x[0])\" , pi = np . pi , degree = 2 ) Visualize Expression In the given code snippet: V = FunctionSpace(mesh, 'CG', 1) : We create a function space V defined on the provided mesh. The function space is based on continuous Galerkin (CG) elements and uses a polynomial degree of 1 for the basis functions. This means that functions in V will be represented as piecewise linear continuous functions over each element of the mesh. f_val = project(f_expr, V) : We use the project function to interpolate the expression f_expr onto the function space V . This creates a new function f_val that represents the projection of the expression f_expr onto the space V . The project function is useful when we want to create functions from Expression and visualize them. V = FunctionSpace ( mesh , 'CG' , 1 ) f_val = project ( f_expr , V ) plt . plot ([ f_val ( x ) for x in np . linspace ( 0 , 1 , 100 )]) [<matplotlib.lines.Line2D at 0x7f9ee473ad68>] L = f_expr * v * dx Compute the solution u_sol = Function ( U ) solve ( a == L , u_sol , bc ) plot ( u_sol ) [<matplotlib.lines.Line2D at 0x7f9ee3061588>] You can pass the co-ordinates of any point inside the mesh to get the value of any FEniCS function at that point u_sol ( 0.5 ) 0.8648790643807451 Post processing def u_exact ( x ): return np . sin ( np . pi * x ) points = np . linspace ( 0 , 1 , 100 ) # Evaluate the exact solution at the mesh points u_exact_values = np . array ([ u_exact ( x ) for x in points ]) # Evaluate the numerical solution at the mesh points u_numerical_values = np . array ([ u_sol ( x ) for x in points ]) # Compute the error error = u_exact_values - u_numerical_values print ( \"L2 error:\" , np . linalg . norm ( error )) L2 error: 0.6951127497810745 plt . figure () plt . plot ( points , u_exact_values , \"--\" , label = 'Exact solution' , linewidth = 3 ) plt . plot ( points , u_numerical_values , label = 'Numerical solution' ) plt . xlabel ( 'x' ) plt . ylabel ( 'u(x)' ) plt . legend () plt . title ( 'Manufactured solution of Poisson \\' s equation' ) plt . grid () plt . show () !pip install plotly import plotly.express as px # Convert mesh coordinates and solutions to DataFrame for Plotly Express import pandas as pd data = pd . DataFrame ({ 'x' : points , 'Exact solution' : [ u_exact ( x ) for x in points ], 'Numerical solution' : [ u_sol ( x ) for x in points ]}) # Create a Plotly Express figure with colors specified fig = px . line ( data , x = 'x' , y = [ 'Exact solution' , 'Numerical solution' ], title = 'Manufactured solution of Poisson \\' s equation' , color_discrete_map = { 'Exact solution' : 'black' , 'Numerical solution' : 'blue' }) fig . update_traces ( mode = \"lines\" , hovertemplate = None ) # Set the figure size to achieve a 1:1 aspect ratio fig . update_layout ( hovermode = 'x' , autosize = False , width = 800 , # You can adjust this value to get the desired aspect ratio height = 500 ) # Show the Plotly Express figure fig . show ()","title":"Poissons Equation"},{"location":"2_tutorials/1_linear_poisson/#poissons-equation","text":"Welcome to this FEniCS tutorial, where we will explore how to verify the accuracy of a Poisson's equation solver using the \"manufactured solution\" technique. FEniCS is a powerful open-source finite element library for solving partial differential equations (PDEs), widely used for scientific computing and simulation. The \"manufactured solution\" approach is a valuable method to validate the correctness of finite element implementations. In this technique, we first construct an exact solution to the PDE, often a smooth and analytically known function, that satisfies the given equation. Next, we compute the corresponding right-hand side of the PDE using the exact solution. By feeding the manufactured solution and the derived right-hand side into our FEniCS solver, we can compare the numerical solution with the exact solution, thus quantifying the solver's accuracy. In this tutorial, we will focus on solving the one-dimensional Poisson's equation: \\[\\begin{split}- \\nabla^{2} u &= f \\quad {\\rm in} \\ \\Omega, \\\\ u &= 0 \\quad {\\rm on} \\ \\Gamma_{D}, \\\\ \\nabla u \\cdot n &= g \\quad {\\rm on} \\ \\Gamma_{N}. \\\\\\end{split} \\] subject to homogeneous Dirichlet boundary conditions, where u(x) is the unknown function, and f(x) is the right-hand side. We will construct a simple manufactured solution, u_exact(x), and calculate the corresponding f(x) that satisfies the equation. Throughout the tutorial, we will cover the following steps: Importing the necessary modules. Defining the manufactured solution and its corresponding right-hand side. Creating the one-dimensional mesh using FEniCS. Defining the appropriate FunctionSpace for the problem. Imposing the homogeneous Dirichlet boundary conditions. Formulating the variational problem using FEniCS's TrialFunction and TestFunction. Solving the Poisson's equation using FEniCS's solve function. Comparing the numerical solution with the exact solution to quantify the solver's accuracy. By the end of this tutorial, you will have a better understanding of the manufactured solution technique, its importance in validating finite element solvers, and how to implement it using FEniCS on an interval mesh. So, let's get started with our journey into the world - of FEniCS and manufactured solutions!","title":"Poissons Equation"},{"location":"2_tutorials/1_linear_poisson/#step-1-import-the-necessary-modules","text":"from dolfin import * import numpy as np import matplotlib.pyplot as plt % matplotlib inline","title":"Step 1: Import the necessary modules"},{"location":"2_tutorials/1_linear_poisson/#step-2-define-the-mesh","text":"# Create the mesh num_elements = 3 # num_elements equally spaced intervals in [0, 1] mesh = IntervalMesh ( num_elements , 0 , 1 ) plot ( mesh ) [<matplotlib.lines.Line2D at 0x7f9f10e6d4e0>]","title":"Step 2: Define the mesh"},{"location":"2_tutorials/1_linear_poisson/#step-3-define-the-function-space","text":"The line of code U = FunctionSpace(mesh, \"CG\", 1) in FEniCS creates a function space U based on linear continuous elements ( CG ) defined on the mesh with degree 1 polynomial approximation. U = FunctionSpace ( mesh , \"CG\" , 1 )","title":"Step 3: Define the function space"},{"location":"2_tutorials/1_linear_poisson/#step-4-define-boundary-condition","text":"We create a DirichletBC object ( bc ) that associates the function space U with the boundary condition u_D and the subdomain boundary . This means that the solution function u_sol will have the value 0.0 on the boundary of the domain during the solution of the PDE . u_D = Constant ( 0.0 ) boundary = CompiledSubDomain ( \"on_boundary\" ) bc = DirichletBC ( U , u_D , boundary )","title":"Step 4: Define boundary condition"},{"location":"2_tutorials/1_linear_poisson/#step-5-define-weak-form","text":"\\[a(u, v) = L(v) \\quad \\forall \\ v \\in V,$$ $$\\begin{split}a(u, v) &= \\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, {\\rm d} x, \\\\ L(v) &= \\int_{\\Omega} f v \\, {\\rm d} x.\\end{split}\\] u = TrialFunction ( U ) v = TestFunction ( U ) a = inner ( grad ( u ), grad ( v )) * dx","title":"Step 5: Define weak form"},{"location":"2_tutorials/1_linear_poisson/#step-51-define-the-manufactured-rhs","text":"For this tutorial, let's choose a simple manufactured solution. We will solve the Poisson's equation in 1D: \\[-\\Delta u(x) = f(x), 0 < x < 1,\\] where u(x) is the unknown function, and f(x) is the right-hand side. We will choose an analytical solution u_exact(x) that satisfies the above equation. For this example, let's take: \\[u_{exact}(x) = sin(\\pi x)\\] and calculate the corresponding f(x): \\[f(x) = -\\Delta u_{exact}(x) = \\pi^2 sin(\\pi x)\\] f_expr = Expression ( \"pi*pi*sin(pi*x[0])\" , pi = np . pi , degree = 2 )","title":"Step 5.1: Define the manufactured rhs"},{"location":"2_tutorials/1_linear_poisson/#visualize-expression","text":"In the given code snippet: V = FunctionSpace(mesh, 'CG', 1) : We create a function space V defined on the provided mesh. The function space is based on continuous Galerkin (CG) elements and uses a polynomial degree of 1 for the basis functions. This means that functions in V will be represented as piecewise linear continuous functions over each element of the mesh. f_val = project(f_expr, V) : We use the project function to interpolate the expression f_expr onto the function space V . This creates a new function f_val that represents the projection of the expression f_expr onto the space V . The project function is useful when we want to create functions from Expression and visualize them. V = FunctionSpace ( mesh , 'CG' , 1 ) f_val = project ( f_expr , V ) plt . plot ([ f_val ( x ) for x in np . linspace ( 0 , 1 , 100 )]) [<matplotlib.lines.Line2D at 0x7f9ee473ad68>] L = f_expr * v * dx","title":"Visualize Expression"},{"location":"2_tutorials/1_linear_poisson/#compute-the-solution","text":"u_sol = Function ( U ) solve ( a == L , u_sol , bc ) plot ( u_sol ) [<matplotlib.lines.Line2D at 0x7f9ee3061588>] You can pass the co-ordinates of any point inside the mesh to get the value of any FEniCS function at that point u_sol ( 0.5 ) 0.8648790643807451","title":"Compute the solution"},{"location":"2_tutorials/1_linear_poisson/#post-processing","text":"def u_exact ( x ): return np . sin ( np . pi * x ) points = np . linspace ( 0 , 1 , 100 ) # Evaluate the exact solution at the mesh points u_exact_values = np . array ([ u_exact ( x ) for x in points ]) # Evaluate the numerical solution at the mesh points u_numerical_values = np . array ([ u_sol ( x ) for x in points ]) # Compute the error error = u_exact_values - u_numerical_values print ( \"L2 error:\" , np . linalg . norm ( error )) L2 error: 0.6951127497810745 plt . figure () plt . plot ( points , u_exact_values , \"--\" , label = 'Exact solution' , linewidth = 3 ) plt . plot ( points , u_numerical_values , label = 'Numerical solution' ) plt . xlabel ( 'x' ) plt . ylabel ( 'u(x)' ) plt . legend () plt . title ( 'Manufactured solution of Poisson \\' s equation' ) plt . grid () plt . show () !pip install plotly import plotly.express as px # Convert mesh coordinates and solutions to DataFrame for Plotly Express import pandas as pd data = pd . DataFrame ({ 'x' : points , 'Exact solution' : [ u_exact ( x ) for x in points ], 'Numerical solution' : [ u_sol ( x ) for x in points ]}) # Create a Plotly Express figure with colors specified fig = px . line ( data , x = 'x' , y = [ 'Exact solution' , 'Numerical solution' ], title = 'Manufactured solution of Poisson \\' s equation' , color_discrete_map = { 'Exact solution' : 'black' , 'Numerical solution' : 'blue' }) fig . update_traces ( mode = \"lines\" , hovertemplate = None ) # Set the figure size to achieve a 1:1 aspect ratio fig . update_layout ( hovermode = 'x' , autosize = False , width = 800 , # You can adjust this value to get the desired aspect ratio height = 500 ) # Show the Plotly Express figure fig . show ()","title":"Post processing"},{"location":"3_exercises/1_getting_started/","text":"","title":"API"}]}