{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction to FEniCS This is a five-day course focused on solving partial differential equations (PDEs) using the FEniCS software package. The goal is to introduce the students to PDEs encountered in various engineering and science disciplines, such as solid mechanics, heat transfer, and mass transport. The course materials, including tutorials and exercises, were created as part of a five-day workshop at IIT Madras, in collaboration with Vanderbilt University, USA. These materials are presented in Jupyter Notebooks , which allow you to see both the code and its explanations, as well as the results, all together. The tutorials are comprehensive notebooks that demonstrate how to approach different types of problems using FEniCS. On the other hand, the exercises are meant to be interactive, and they encourage you to expand the notebooks by adding new functionalities. This way, you can develop your expertise in using FEniCS. What is FEniCS? FEniCS is a high-performance computing (HPC) capable tool that efficiently utilizes supercomputers and high-performance clusters to solve complex scientific problems. It supports parallel computing, JIT compilation, and integrates with PETSc and MPI for scalability and performance. Its HPC capabilities enable researchers to perform large-scale simulations and analyses effectively. FEniCS is an acronym FEniCS is an acronym that stands for \"Finite Element Computational Software.\" The inclusion of \"ni\" in the name is to create a balanced and appealing composition. The FEniCS software package was compiled at the University of Chicago, whose Phoenix mascot likely influenced the choice of the name. Github Repo FEniCS Workshop Authors Abhinav Gupta Ravindra Duddu","title":"Home"},{"location":"#introduction-to-fenics","text":"This is a five-day course focused on solving partial differential equations (PDEs) using the FEniCS software package. The goal is to introduce the students to PDEs encountered in various engineering and science disciplines, such as solid mechanics, heat transfer, and mass transport. The course materials, including tutorials and exercises, were created as part of a five-day workshop at IIT Madras, in collaboration with Vanderbilt University, USA. These materials are presented in Jupyter Notebooks , which allow you to see both the code and its explanations, as well as the results, all together. The tutorials are comprehensive notebooks that demonstrate how to approach different types of problems using FEniCS. On the other hand, the exercises are meant to be interactive, and they encourage you to expand the notebooks by adding new functionalities. This way, you can develop your expertise in using FEniCS.","title":"Introduction to FEniCS"},{"location":"#what-is-fenics","text":"FEniCS is a high-performance computing (HPC) capable tool that efficiently utilizes supercomputers and high-performance clusters to solve complex scientific problems. It supports parallel computing, JIT compilation, and integrates with PETSc and MPI for scalability and performance. Its HPC capabilities enable researchers to perform large-scale simulations and analyses effectively. FEniCS is an acronym FEniCS is an acronym that stands for \"Finite Element Computational Software.\" The inclusion of \"ni\" in the name is to create a balanced and appealing composition. The FEniCS software package was compiled at the University of Chicago, whose Phoenix mascot likely influenced the choice of the name.","title":"What is FEniCS?"},{"location":"#github-repo","text":"FEniCS Workshop","title":"Github Repo"},{"location":"#authors","text":"Abhinav Gupta Ravindra Duddu","title":"Authors"},{"location":"1_introduction/1_motivation/","text":"The motivation to create the Introduction to FEniCS course stems from several key objectives to address the needs and challenges faced by students and professionals in engineering and science disciplines. These motivations include: Bridging the Gap in PDE Problem-Solving Skills: The course is designed to equip participants with the necessary tools to solve partial differential equations (PDEs), which are prevalent in various fields such as solid mechanics, heat transfer, and mass transport. There is a recognized need for advanced problem-solving skills in these areas, and FEniCS offers a robust solution. Introducing High-Performance Computing (HPC) to a Wider Audience: FEniCS is not just another computational tool; it's a high-performance computing-capable platform that can significantly enhance the efficiency and scope of scientific computations. The course aims to democratize access to HPC capabilities, enabling more researchers and practitioners to perform large-scale simulations and complex analyses. Enhancing Interactive and Practical Learning: Traditional learning methods may need to equip learners to handle PDEs' real-world complexities fully. By using Jupyter Notebooks and interactive exercises, the course promotes an active learning environment where participants can see the immediate impact of the code they write and understand the practical applications of the theoretical concepts they learn. Promoting Collaborative and Cutting-Edge Research: By training a cohort of skilled individuals capable of utilizing FEniCS for various applications, the course aims to foster collaboration and innovation in scientific research and engineering solutions. The partnership between IIT Madras and Vanderbilt University in creating this course material reflects the global and collaborative approach to education and research. Fulfilling the Need for Scalable and Efficient Solutions: As scientific and engineering problems become more complex, the demand for scalable and efficient computational methods rises. FEniCS, with its capabilities for parallel computing and integration with other HPC tools, offers a pathway to meeting these demands. The course is motivated by the desire to empower participants with these advanced tools to address today's problems and future challenges. In summary, the motivation behind creating the Introduction to FEniCS course is to provide a comprehensive, interactive, and practical learning experience that enhances participants' abilities to solve complex PDEs, introduces them to high-performance computing, and prepares them for collaborative and innovative work in their respective fields.","title":"Motivation"},{"location":"1_introduction/2_installation/","text":"Prerequisites To follow along with the examples, you need to install docker on your system. You need Windows 10/11 Education or Professional for this to work. This does not work on Windows 10/11 Home. Docker Paraview CMDER (Only for Windows) (After installation, open cmder and then go to Settings(Win+Alt+P)\u27a1import and choose the cmlab.xml provided in the repository.) Google Chrome (After installation, open Chrome and paste the following in the address bar, chrome://flags/. In the flags screen, enable WebGL Developer Extensions ) Install FEniCS Once the docker system is installed and running, open CMDER/terminal and run: docker pull iitrabhi/fenics_notebook Running To start the notebook server, use the following: docker run -p 8888:8888 -v host_system_path:/root/ -w /root/ iitrabhi/fenics_notebook Note: you should replace the variable host_system_path with the path of the folder that contains your code. e.g., If D:\\Codes contains your code, then to start the command line interface, you have to run: docker run -p 8888:8888 -v D:\\Codes:/root/ -w /root/ iitrabhi/fenics_notebook Once you run the above command in cmder, you will get a URL starting with http://127.0.0.1:8888/lab . Press Control and click on the URL to open a new Jupyter Notebook. If you have Windows home You can use google collab to run FEniCS on the cloud. Open Collab , upload your notebook and paste the following in the first cell of your notebook. try: import dolfin except ImportError: !wget \"https://fem-on-colab.github.io/releases/fenics-install.sh\" -O \"/tmp/fenics-install.sh\" && bash \"/tmp/fenics-install.sh\" import dolfin https://fem-on-colab.github.io/packages.html","title":"Installation"},{"location":"1_introduction/2_installation/#prerequisites","text":"To follow along with the examples, you need to install docker on your system. You need Windows 10/11 Education or Professional for this to work. This does not work on Windows 10/11 Home. Docker Paraview CMDER (Only for Windows) (After installation, open cmder and then go to Settings(Win+Alt+P)\u27a1import and choose the cmlab.xml provided in the repository.) Google Chrome (After installation, open Chrome and paste the following in the address bar, chrome://flags/. In the flags screen, enable WebGL Developer Extensions )","title":"Prerequisites"},{"location":"1_introduction/2_installation/#install-fenics","text":"Once the docker system is installed and running, open CMDER/terminal and run: docker pull iitrabhi/fenics_notebook","title":"Install FEniCS"},{"location":"1_introduction/2_installation/#running","text":"To start the notebook server, use the following: docker run -p 8888:8888 -v host_system_path:/root/ -w /root/ iitrabhi/fenics_notebook Note: you should replace the variable host_system_path with the path of the folder that contains your code. e.g., If D:\\Codes contains your code, then to start the command line interface, you have to run: docker run -p 8888:8888 -v D:\\Codes:/root/ -w /root/ iitrabhi/fenics_notebook Once you run the above command in cmder, you will get a URL starting with http://127.0.0.1:8888/lab . Press Control and click on the URL to open a new Jupyter Notebook.","title":"Running"},{"location":"1_introduction/2_installation/#if-you-have-windows-home","text":"You can use google collab to run FEniCS on the cloud. Open Collab , upload your notebook and paste the following in the first cell of your notebook. try: import dolfin except ImportError: !wget \"https://fem-on-colab.github.io/releases/fenics-install.sh\" -O \"/tmp/fenics-install.sh\" && bash \"/tmp/fenics-install.sh\" import dolfin https://fem-on-colab.github.io/packages.html","title":"If you have Windows home"},{"location":"1_introduction/3_quickstart/","text":"","title":"Quickstart"},{"location":"1_introduction/4_faq/","text":"Where to find help When in doubt about any specific FEniCS command or implementation, there are several resources you can refer to for clarification and assistance: FEniCS Book: The official FEniCS book is an invaluable resource. It provides comprehensive documentation, tutorials, examples, and detailed explanations of all FEniCS functionalities. You can find it at: The FEniCS Book FEniCS Q&A Forum: The FEniCS Q&A forum is an active community where users and developers discuss issues, ask questions, and share knowledge about FEniCS. You can post your questions here and get help from experienced FEniCS users and developers. Access the forum at FEniCS discourse FEniCS Workshop Slack channel: You can also join the FEniCS workshop community on Slack to connect with other users, developers, and experts in the field. Slack is an excellent platform for real-time discussions, sharing knowledge, and getting help with FEniCS-related topics. You can join the Slack community by using this link . FEniCS online documentation: The online documentation since V1.3.0 is available at this link . You can go into the python folder of any version to find the syntax and meaning of different commands. The latest version is not that descriptive, and thus I recommend checking out older documentation, as most of the commands are the same. Note: Please go through the official community page here . Books to read Bleyer, Jeremy. \u201cNumerical Tours of Continuum Mechanics Using FEniCS,\u201d n.d., 105. Langtangen, Hans Petter, and Anders Logg. \u201cSolving PDEs in Python \u2013 The FEniCS Tutorial Volume I,\u201d n.d., 153. Langtangen, Hans Petter, and Kent-Andre Mardal. \u201cIntroduction to Numerical Methods for Variational Problems\u201d. Vol. 21. Texts in Computational Science and Engineering. Cham: Springer International Publishing, 2019. https://doi.org/10.1007/978-3-030-23788-2. Logg, Anders, Kent-Andre Mardal, and Garth Wells, eds. \u201cAutomated Solution of Differential Equations by the Finite Element Method\u201d. Vol. 84. Lecture Notes in Computational Science and Engineering. Berlin, Heidelberg: Springer Berlin Heidelberg, 2012. https://doi.org/10.1007/978-3-642-23099-8.","title":"FAQ"},{"location":"1_introduction/4_faq/#where-to-find-help","text":"When in doubt about any specific FEniCS command or implementation, there are several resources you can refer to for clarification and assistance: FEniCS Book: The official FEniCS book is an invaluable resource. It provides comprehensive documentation, tutorials, examples, and detailed explanations of all FEniCS functionalities. You can find it at: The FEniCS Book FEniCS Q&A Forum: The FEniCS Q&A forum is an active community where users and developers discuss issues, ask questions, and share knowledge about FEniCS. You can post your questions here and get help from experienced FEniCS users and developers. Access the forum at FEniCS discourse FEniCS Workshop Slack channel: You can also join the FEniCS workshop community on Slack to connect with other users, developers, and experts in the field. Slack is an excellent platform for real-time discussions, sharing knowledge, and getting help with FEniCS-related topics. You can join the Slack community by using this link . FEniCS online documentation: The online documentation since V1.3.0 is available at this link . You can go into the python folder of any version to find the syntax and meaning of different commands. The latest version is not that descriptive, and thus I recommend checking out older documentation, as most of the commands are the same. Note: Please go through the official community page here .","title":"Where to find help"},{"location":"1_introduction/4_faq/#books-to-read","text":"Bleyer, Jeremy. \u201cNumerical Tours of Continuum Mechanics Using FEniCS,\u201d n.d., 105. Langtangen, Hans Petter, and Anders Logg. \u201cSolving PDEs in Python \u2013 The FEniCS Tutorial Volume I,\u201d n.d., 153. Langtangen, Hans Petter, and Kent-Andre Mardal. \u201cIntroduction to Numerical Methods for Variational Problems\u201d. Vol. 21. Texts in Computational Science and Engineering. Cham: Springer International Publishing, 2019. https://doi.org/10.1007/978-3-030-23788-2. Logg, Anders, Kent-Andre Mardal, and Garth Wells, eds. \u201cAutomated Solution of Differential Equations by the Finite Element Method\u201d. Vol. 84. Lecture Notes in Computational Science and Engineering. Berlin, Heidelberg: Springer Berlin Heidelberg, 2012. https://doi.org/10.1007/978-3-642-23099-8.","title":"Books to read"},{"location":"2_notebooks/day-1/exercises/1_built_in_mesh/","text":"Built in meshes FEniCS provides built-in capabilities to generate various types of meshes, allowing users to focus on the core of their simulations. Please visit the official documentation link provided to learn how to modify the mesh. After familiarizing yourself with the process, return here to implement the changes and visualize the updated results. https://fenicsproject.org/olddocs/dolfin/latest/python/demos/built-in-meshes/demo_built-in-meshes.py.html from dolfin import * Change this portion of the code to: 1. Make a 2D unit square mesh. 2. Make a rectangle mesh with dimension \\(2 \\times 1\\) mesh = IntervalMesh ( 30 , 0 , 1 ) U = FunctionSpace ( mesh , \"CG\" , 1 ) u_D = Constant ( 0.0 ) boundary = CompiledSubDomain ( \"on_boundary\" ) bc = DirichletBC ( U , u_D , boundary ) u , v = TrialFunction ( U ), TestFunction ( U ) a = inner ( grad ( u ), grad ( v )) * dx f_expr = Expression ( \"pi*pi*sin(pi*x[0])\" , pi = np . pi , degree = 2 ) L = f_expr * v * dx u_sol = Function ( U , name = \"field\" ) solve ( a == L , u_sol , bc ) with XDMFFile ( \"output/result.xdmf\" ) as outfile : outfile . write ( u_sol )","title":"1_built_in_mesh.md"},{"location":"2_notebooks/day-1/exercises/1_built_in_mesh/#built-in-meshes","text":"FEniCS provides built-in capabilities to generate various types of meshes, allowing users to focus on the core of their simulations. Please visit the official documentation link provided to learn how to modify the mesh. After familiarizing yourself with the process, return here to implement the changes and visualize the updated results. https://fenicsproject.org/olddocs/dolfin/latest/python/demos/built-in-meshes/demo_built-in-meshes.py.html from dolfin import * Change this portion of the code to: 1. Make a 2D unit square mesh. 2. Make a rectangle mesh with dimension \\(2 \\times 1\\) mesh = IntervalMesh ( 30 , 0 , 1 ) U = FunctionSpace ( mesh , \"CG\" , 1 ) u_D = Constant ( 0.0 ) boundary = CompiledSubDomain ( \"on_boundary\" ) bc = DirichletBC ( U , u_D , boundary ) u , v = TrialFunction ( U ), TestFunction ( U ) a = inner ( grad ( u ), grad ( v )) * dx f_expr = Expression ( \"pi*pi*sin(pi*x[0])\" , pi = np . pi , degree = 2 ) L = f_expr * v * dx u_sol = Function ( U , name = \"field\" ) solve ( a == L , u_sol , bc ) with XDMFFile ( \"output/result.xdmf\" ) as outfile : outfile . write ( u_sol )","title":"Built in meshes"},{"location":"2_notebooks/day-1/exercises/2_boundary_conditions/","text":"Boundary conditions In FEniCS, the \"CompiledSubDomain\" class is a useful tool that allows users to define complex subdomains within a given computational domain for finite element simulations. Subdomains are portions of the computational domain where different physical or material properties are applied, or specific boundary conditions are imposed. The primary advantage of using the \"CompiledSubDomain\" class is that it allows you to define subdomains using mathematical expressions or conditions, which are then compiled into efficient C++ code. This compiled code is utilized during the simulation, providing a significant performance boost compared to interpreting the subdomain expressions directly in Python. Please visit the official documentation link provided to learn how to modify the bounday conditions using \"CompiledSubDomain\". After familiarizing yourself with the process, return here to implement the changes and visualize the updated results. https://fenicsproject.org/pub/tutorial/sphinx1/._ftut1005.html#using-c-code-snippets-to-define-subdomains from dolfin import * Change this portion of the code to: 1. Make a 2D unit square mesh. mesh = IntervalMesh ( 30 , 0 , 1 ) U = FunctionSpace ( mesh , \"CG\" , 1 ) Change this portion of the code to: 1. Mark only the left edge as fixed. 2. Mark the left and top edge as fixed. u_D = Constant ( 0.0 ) boundary = CompiledSubDomain ( \"on_boundary\" ) bc = DirichletBC ( U , u_D , boundary ) u , v = TrialFunction ( U ), TestFunction ( U ) a = inner ( grad ( u ), grad ( v )) * dx f_expr = Expression ( \"pi*pi*sin(pi*x[0])\" , pi = np . pi , degree = 2 ) L = f_expr * v * dx u_sol = Function ( U , name = \"field\" ) solve ( a == L , u_sol , bc ) with XDMFFile ( \"output/result.xdmf\" ) as outfile : outfile . write ( u_sol )","title":"2_boundary_conditions.md"},{"location":"2_notebooks/day-1/exercises/2_boundary_conditions/#boundary-conditions","text":"In FEniCS, the \"CompiledSubDomain\" class is a useful tool that allows users to define complex subdomains within a given computational domain for finite element simulations. Subdomains are portions of the computational domain where different physical or material properties are applied, or specific boundary conditions are imposed. The primary advantage of using the \"CompiledSubDomain\" class is that it allows you to define subdomains using mathematical expressions or conditions, which are then compiled into efficient C++ code. This compiled code is utilized during the simulation, providing a significant performance boost compared to interpreting the subdomain expressions directly in Python. Please visit the official documentation link provided to learn how to modify the bounday conditions using \"CompiledSubDomain\". After familiarizing yourself with the process, return here to implement the changes and visualize the updated results. https://fenicsproject.org/pub/tutorial/sphinx1/._ftut1005.html#using-c-code-snippets-to-define-subdomains from dolfin import * Change this portion of the code to: 1. Make a 2D unit square mesh. mesh = IntervalMesh ( 30 , 0 , 1 ) U = FunctionSpace ( mesh , \"CG\" , 1 ) Change this portion of the code to: 1. Mark only the left edge as fixed. 2. Mark the left and top edge as fixed. u_D = Constant ( 0.0 ) boundary = CompiledSubDomain ( \"on_boundary\" ) bc = DirichletBC ( U , u_D , boundary ) u , v = TrialFunction ( U ), TestFunction ( U ) a = inner ( grad ( u ), grad ( v )) * dx f_expr = Expression ( \"pi*pi*sin(pi*x[0])\" , pi = np . pi , degree = 2 ) L = f_expr * v * dx u_sol = Function ( U , name = \"field\" ) solve ( a == L , u_sol , bc ) with XDMFFile ( \"output/result.xdmf\" ) as outfile : outfile . write ( u_sol )","title":"Boundary conditions"},{"location":"2_notebooks/day-1/exercises/3_expressions/","text":"Expressions In FEniCS, an Expression is a flexible and convenient way to define mathematical functions or expressions within the domain of interest. Expressions are often used to specify boundary conditions, source terms, initial conditions, or any other function needed in the formulation of the PDE problem. The beauty of using Expressions lies in their simplicity and directness. Users can define an Expression using a concise mathematical expression, incorporating spatial coordinates and/or time variables. Additionally, FEniCS supports the use of elementary mathematical functions, mathematical constants, and custom-defined functions within Expressions. Please visit the official documentation link provided to learn how to modify expressions. After familiarizing yourself with the process, return here to implement the changes and visualize the updated results. https://fenicsproject.org/pub/tutorial/sphinx1/._ftut1003.html#index-28 from dolfin import * Change this portion of the code to: 1. Make a 2D unit square mesh. mesh = IntervalMesh ( 30 , 0 , 1 ) U = FunctionSpace ( mesh , \"CG\" , 1 ) u_D = Constant ( 0.0 ) boundary = CompiledSubDomain ( \"on_boundary\" ) bc = DirichletBC ( U , u_D , boundary ) u , v = TrialFunction ( U ), TestFunction ( U ) a = inner ( grad ( u ), grad ( v )) * dx Change this portion of the code to: 1. Change the forcing function to \\(f(x) = x\\) 2. Change the forcing function to \\(f(x,y) = sin(\\pi x)sin(\\pi y)\\) f_expr = Expression ( \"pi*pi*sin(pi*x[0])\" , pi = np . pi , degree = 2 ) L = f_expr * v * dx u_sol = Function ( U , name = \"field\" ) solve ( a == L , u_sol , bc ) with XDMFFile ( \"output/result.xdmf\" ) as outfile : outfile . write ( u_sol )","title":"3_expressions.md"},{"location":"2_notebooks/day-1/exercises/3_expressions/#expressions","text":"In FEniCS, an Expression is a flexible and convenient way to define mathematical functions or expressions within the domain of interest. Expressions are often used to specify boundary conditions, source terms, initial conditions, or any other function needed in the formulation of the PDE problem. The beauty of using Expressions lies in their simplicity and directness. Users can define an Expression using a concise mathematical expression, incorporating spatial coordinates and/or time variables. Additionally, FEniCS supports the use of elementary mathematical functions, mathematical constants, and custom-defined functions within Expressions. Please visit the official documentation link provided to learn how to modify expressions. After familiarizing yourself with the process, return here to implement the changes and visualize the updated results. https://fenicsproject.org/pub/tutorial/sphinx1/._ftut1003.html#index-28 from dolfin import * Change this portion of the code to: 1. Make a 2D unit square mesh. mesh = IntervalMesh ( 30 , 0 , 1 ) U = FunctionSpace ( mesh , \"CG\" , 1 ) u_D = Constant ( 0.0 ) boundary = CompiledSubDomain ( \"on_boundary\" ) bc = DirichletBC ( U , u_D , boundary ) u , v = TrialFunction ( U ), TestFunction ( U ) a = inner ( grad ( u ), grad ( v )) * dx Change this portion of the code to: 1. Change the forcing function to \\(f(x) = x\\) 2. Change the forcing function to \\(f(x,y) = sin(\\pi x)sin(\\pi y)\\) f_expr = Expression ( \"pi*pi*sin(pi*x[0])\" , pi = np . pi , degree = 2 ) L = f_expr * v * dx u_sol = Function ( U , name = \"field\" ) solve ( a == L , u_sol , bc ) with XDMFFile ( \"output/result.xdmf\" ) as outfile : outfile . write ( u_sol )","title":"Expressions"},{"location":"2_notebooks/day-1/exercises/4_spacially_varying_properties/","text":"Spacially varying properties With FEniCS, researchers and engineers can model and simulate problems with spatially varying material properties efficiently and accurately. We can use the Expression class provided by FEniCS to represent the material property as a function of the co-ordinate of the mesh. Please visit the official documentation link provided to learn how to modify expressions. After familiarizing yourself with the process, return here to implement the changes and visualize the updated results. https://fenicsproject.org/pub/tutorial/sphinx1/._ftut1003.html#index-28 from dolfin import * Change this portion of the code to: 1. Make a 2D unit square mesh. mesh = IntervalMesh ( 30 , 0 , 1 ) U = FunctionSpace ( mesh , \"CG\" , 1 ) Change this portion of the code to: 1. Change the material property to \\(E(x) = 10 + x\\) E = Constant ( 10 ) u_D = Constant ( 0.0 ) boundary = CompiledSubDomain ( \"on_boundary\" ) bc = DirichletBC ( U , u_D , boundary ) u , v = TrialFunction ( U ), TestFunction ( U ) a = E * inner ( grad ( u ), grad ( v )) * dx f_expr = Expression ( \"pi*pi*sin(pi*x[0])\" , pi = np . pi , degree = 2 ) L = f_expr * v * dx u_sol = Function ( U , name = \"field\" ) solve ( a == L , u_sol , bc ) with XDMFFile ( \"output/result.xdmf\" ) as outfile : outfile . write ( u_sol ) Calling FFC just-in-time (JIT) compiler, this may take some time.","title":"4_spacially_varying_properties.md"},{"location":"2_notebooks/day-1/exercises/4_spacially_varying_properties/#spacially-varying-properties","text":"With FEniCS, researchers and engineers can model and simulate problems with spatially varying material properties efficiently and accurately. We can use the Expression class provided by FEniCS to represent the material property as a function of the co-ordinate of the mesh. Please visit the official documentation link provided to learn how to modify expressions. After familiarizing yourself with the process, return here to implement the changes and visualize the updated results. https://fenicsproject.org/pub/tutorial/sphinx1/._ftut1003.html#index-28 from dolfin import * Change this portion of the code to: 1. Make a 2D unit square mesh. mesh = IntervalMesh ( 30 , 0 , 1 ) U = FunctionSpace ( mesh , \"CG\" , 1 ) Change this portion of the code to: 1. Change the material property to \\(E(x) = 10 + x\\) E = Constant ( 10 ) u_D = Constant ( 0.0 ) boundary = CompiledSubDomain ( \"on_boundary\" ) bc = DirichletBC ( U , u_D , boundary ) u , v = TrialFunction ( U ), TestFunction ( U ) a = E * inner ( grad ( u ), grad ( v )) * dx f_expr = Expression ( \"pi*pi*sin(pi*x[0])\" , pi = np . pi , degree = 2 ) L = f_expr * v * dx u_sol = Function ( U , name = \"field\" ) solve ( a == L , u_sol , bc ) with XDMFFile ( \"output/result.xdmf\" ) as outfile : outfile . write ( u_sol ) Calling FFC just-in-time (JIT) compiler, this may take some time.","title":"Spacially varying properties"},{"location":"2_notebooks/day-1/exercises/5_convergence/","text":"Convergence Convergence analysis in the FEM is a critical process that evaluates the accuracy and reliability of numerical solutions to PDEs. It involves discretizing the continuous problem into a mesh of elements and studying how the numerical solution converges to the exact solution as the mesh is refined. By analyzing various error norms and convergence rates, researchers can determine the reliability of the numerical scheme, select appropriate mesh resolutions, and validate results against analytical solutions. Please visit the official documentation link provided to learn how to modify the mesh. After familiarizing yourself with the process, return here to implement the changes and visualize the updated results. https://fenicsproject.org/olddocs/dolfin/latest/python/demos/built-in-meshes/demo_built-in-meshes.py.html from dolfin import * Change this portion of the code to make a 2D unit square mesh and perform the analysis with mesh size: 1. \\(2\\times 2\\) 2. \\(5\\times 5\\) 3. \\(10\\times 10\\) 4. \\(20\\times 20\\) 5. \\(50\\times 50\\) mesh = IntervalMesh ( 30 , 0 , 1 ) U = FunctionSpace ( mesh , \"CG\" , 1 ) u_D = Constant ( 0.0 ) boundary = CompiledSubDomain ( \"on_boundary\" ) bc = DirichletBC ( U , u_D , boundary ) u , v = TrialFunction ( U ), TestFunction ( U ) a = inner ( grad ( u ), grad ( v )) * dx f_expr = Expression ( \"pi*pi*sin(pi*x[0])\" , pi = np . pi , degree = 2 ) L = f_expr * v * dx u_sol = Function ( U , name = \"field\" ) solve ( a == L , u_sol , bc ) with XDMFFile ( \"output/result.xdmf\" ) as outfile : outfile . write ( u_sol )","title":"5_convergence.md"},{"location":"2_notebooks/day-1/exercises/5_convergence/#convergence","text":"Convergence analysis in the FEM is a critical process that evaluates the accuracy and reliability of numerical solutions to PDEs. It involves discretizing the continuous problem into a mesh of elements and studying how the numerical solution converges to the exact solution as the mesh is refined. By analyzing various error norms and convergence rates, researchers can determine the reliability of the numerical scheme, select appropriate mesh resolutions, and validate results against analytical solutions. Please visit the official documentation link provided to learn how to modify the mesh. After familiarizing yourself with the process, return here to implement the changes and visualize the updated results. https://fenicsproject.org/olddocs/dolfin/latest/python/demos/built-in-meshes/demo_built-in-meshes.py.html from dolfin import * Change this portion of the code to make a 2D unit square mesh and perform the analysis with mesh size: 1. \\(2\\times 2\\) 2. \\(5\\times 5\\) 3. \\(10\\times 10\\) 4. \\(20\\times 20\\) 5. \\(50\\times 50\\) mesh = IntervalMesh ( 30 , 0 , 1 ) U = FunctionSpace ( mesh , \"CG\" , 1 ) u_D = Constant ( 0.0 ) boundary = CompiledSubDomain ( \"on_boundary\" ) bc = DirichletBC ( U , u_D , boundary ) u , v = TrialFunction ( U ), TestFunction ( U ) a = inner ( grad ( u ), grad ( v )) * dx f_expr = Expression ( \"pi*pi*sin(pi*x[0])\" , pi = np . pi , degree = 2 ) L = f_expr * v * dx u_sol = Function ( U , name = \"field\" ) solve ( a == L , u_sol , bc ) with XDMFFile ( \"output/result.xdmf\" ) as outfile : outfile . write ( u_sol )","title":"Convergence"},{"location":"2_notebooks/day-1/tutorials/1_linear_poisson/","text":"Poissons Equation Welcome to this FEniCS tutorial, where we will explore how to verify the accuracy of a Poisson's equation solver using the \"manufactured solution\" technique. FEniCS is a powerful open-source finite element library for solving partial differential equations (PDEs), widely used for scientific computing and simulation. The \"manufactured solution\" approach is a valuable method to validate the correctness of finite element implementations. In this technique, we first construct an exact solution to the PDE, often a smooth and analytically known function, that satisfies the given equation. Next, we compute the corresponding right-hand side of the PDE using the exact solution. By feeding the manufactured solution and the derived right-hand side into our FEniCS solver, we can compare the numerical solution with the exact solution, thus quantifying the solver's accuracy. In this tutorial, we will focus on solving the one-dimensional Poisson's equation: \\[\\begin{split}- \\nabla^{2} u &= f \\quad {\\rm in} \\ \\Omega, \\\\ u &= 0 \\quad {\\rm on} \\ \\Gamma_{D}, \\\\ \\nabla u \\cdot n &= g \\quad {\\rm on} \\ \\Gamma_{N}. \\\\\\end{split} \\] subject to homogeneous Dirichlet boundary conditions, where u(x) is the unknown function, and f(x) is the right-hand side. We will construct a simple manufactured solution, u_exact(x), and calculate the corresponding f(x) that satisfies the equation. Throughout the tutorial, we will cover the following steps: Importing the necessary modules. Defining the manufactured solution and its corresponding right-hand side. Creating the one-dimensional mesh using FEniCS. Defining the appropriate FunctionSpace for the problem. Imposing the homogeneous Dirichlet boundary conditions. Formulating the variational problem using FEniCS's TrialFunction and TestFunction. Solving the Poisson's equation using FEniCS's solve function. Comparing the numerical solution with the exact solution to quantify the solver's accuracy. By the end of this tutorial, you will have a better understanding of the manufactured solution technique, its importance in validating finite element solvers, and how to implement it using FEniCS on an interval mesh. So, let's get started with our journey into the world - of FEniCS and manufactured solutions! Step 1: Import the necessary modules from dolfin import * import numpy as np import matplotlib.pyplot as plt % matplotlib inline Step 2: Define the mesh # Create the mesh num_elements = 3 # num_elements equally spaced intervals in [0, 1] mesh = IntervalMesh ( num_elements , 0 , 1 ) plot ( mesh ) [<matplotlib.lines.Line2D at 0x7f9f10e6d4e0>] Step 3: Define the function space The line of code U = FunctionSpace(mesh, \"CG\", 1) in FEniCS creates a function space U based on linear continuous elements ( CG ) defined on the mesh with degree 1 polynomial approximation. U = FunctionSpace ( mesh , \"CG\" , 1 ) Step 4: Define boundary condition We create a DirichletBC object ( bc ) that associates the function space U with the boundary condition u_D and the subdomain boundary . This means that the solution function u_sol will have the value 0.0 on the boundary of the domain during the solution of the PDE . u_D = Constant ( 0.0 ) boundary = CompiledSubDomain ( \"on_boundary\" ) bc = DirichletBC ( U , u_D , boundary ) Step 5: Define weak form \\[a(u, v) = L(v) \\quad \\forall \\ v \\in V,$$ $$\\begin{split}a(u, v) &= \\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, {\\rm d} x, \\\\ L(v) &= \\int_{\\Omega} f v \\, {\\rm d} x.\\end{split}\\] u = TrialFunction ( U ) v = TestFunction ( U ) a = inner ( grad ( u ), grad ( v )) * dx Step 5.1: Define the manufactured rhs For this tutorial, let's choose a simple manufactured solution. We will solve the Poisson's equation in 1D: \\[-\\Delta u(x) = f(x), 0 < x < 1,\\] where u(x) is the unknown function, and f(x) is the right-hand side. We will choose an analytical solution u_exact(x) that satisfies the above equation. For this example, let's take: \\[u_{exact}(x) = sin(\\pi x)\\] and calculate the corresponding f(x): \\[f(x) = -\\Delta u_{exact}(x) = \\pi^2 sin(\\pi x)\\] f_expr = Expression ( \"pi*pi*sin(pi*x[0])\" , pi = np . pi , degree = 2 ) Visualize Expression In the given code snippet: V = FunctionSpace(mesh, 'CG', 1) : We create a function space V defined on the provided mesh. The function space is based on continuous Galerkin (CG) elements and uses a polynomial degree of 1 for the basis functions. This means that functions in V will be represented as piecewise linear continuous functions over each element of the mesh. f_val = project(f_expr, V) : We use the project function to interpolate the expression f_expr onto the function space V . This creates a new function f_val that represents the projection of the expression f_expr onto the space V . The project function is useful when we want to create functions from Expression and visualize them. V = FunctionSpace ( mesh , 'CG' , 1 ) f_val = project ( f_expr , V ) plt . plot ([ f_val ( x ) for x in np . linspace ( 0 , 1 , 100 )]) [<matplotlib.lines.Line2D at 0x7f9ee473ad68>] L = f_expr * v * dx Compute the solution u_sol = Function ( U ) solve ( a == L , u_sol , bc ) plot ( u_sol ) [<matplotlib.lines.Line2D at 0x7f9ee3061588>] You can pass the co-ordinates of any point inside the mesh to get the value of any FEniCS function at that point u_sol ( 0.5 ) 0.8648790643807451 Post processing def u_exact ( x ): return np . sin ( np . pi * x ) points = np . linspace ( 0 , 1 , 100 ) # Evaluate the exact solution at the mesh points u_exact_values = np . array ([ u_exact ( x ) for x in points ]) # Evaluate the numerical solution at the mesh points u_numerical_values = np . array ([ u_sol ( x ) for x in points ]) # Compute the error error = u_exact_values - u_numerical_values print ( \"L2 error:\" , np . linalg . norm ( error )) L2 error: 0.6951127497810745 plt . figure () plt . plot ( points , u_exact_values , \"--\" , label = 'Exact solution' , linewidth = 3 ) plt . plot ( points , u_numerical_values , label = 'Numerical solution' ) plt . xlabel ( 'x' ) plt . ylabel ( 'u(x)' ) plt . legend () plt . title ( 'Manufactured solution of Poisson \\' s equation' ) plt . grid () plt . show () !pip install plotly import plotly.express as px # Convert mesh coordinates and solutions to DataFrame for Plotly Express import pandas as pd data = pd . DataFrame ({ 'x' : points , 'Exact solution' : [ u_exact ( x ) for x in points ], 'Numerical solution' : [ u_sol ( x ) for x in points ]}) # Create a Plotly Express figure with colors specified fig = px . line ( data , x = 'x' , y = [ 'Exact solution' , 'Numerical solution' ], title = 'Manufactured solution of Poisson \\' s equation' , color_discrete_map = { 'Exact solution' : 'black' , 'Numerical solution' : 'blue' }) fig . update_traces ( mode = \"lines\" , hovertemplate = None ) # Set the figure size to achieve a 1:1 aspect ratio fig . update_layout ( hovermode = 'x' , autosize = False , width = 800 , # You can adjust this value to get the desired aspect ratio height = 500 ) # Show the Plotly Express figure fig . show () require([\"plotly\"], function(Plotly) { window.PLOTLYENV=window.PLOTLYENV || {}; if (document.getElementById(\"9795c319-ae78-4999-8578-d00e1dfa8c61\")) { Plotly.newPlot( \"9795c319-ae78-4999-8578-d00e1dfa8c61\", [{\"legendgroup\":\"Exact solution\",\"line\":{\"color\":\"black\",\"dash\":\"solid\"},\"marker\":{\"symbol\":\"circle\"},\"mode\":\"lines\",\"name\":\"Exact solution\",\"orientation\":\"v\",\"showlegend\":true,\"x\":[0.0,0.010101010101010102,0.020202020202020204,0.030303030303030304,0.04040404040404041,0.05050505050505051,0.06060606060606061,0.07070707070707072,0.08080808080808081,0.09090909090909091,0.10101010101010102,0.11111111111111112,0.12121212121212122,0.13131313131313133,0.14141414141414144,0.15151515151515152,0.16161616161616163,0.17171717171717174,0.18181818181818182,0.19191919191919193,0.20202020202020204,0.21212121212121213,0.22222222222222224,0.23232323232323235,0.24242424242424243,0.25252525252525254,0.26262626262626265,0.27272727272727276,0.2828282828282829,0.29292929292929293,0.30303030303030304,0.31313131313131315,0.32323232323232326,0.33333333333333337,0.3434343434343435,0.3535353535353536,0.36363636363636365,0.37373737373737376,0.38383838383838387,0.393939393939394,0.4040404040404041,0.4141414141414142,0.42424242424242425,0.43434343434343436,0.4444444444444445,0.4545454545454546,0.4646464646464647,0.4747474747474748,0.48484848484848486,0.494949494949495,0.5050505050505051,0.5151515151515152,0.5252525252525253,0.5353535353535354,0.5454545454545455,0.5555555555555556,0.5656565656565657,0.5757575757575758,0.5858585858585859,0.595959595959596,0.6060606060606061,0.6161616161616162,0.6262626262626263,0.6363636363636365,0.6464646464646465,0.6565656565656566,0.6666666666666667,0.6767676767676768,0.686868686868687,0.696969696969697,0.7070707070707072,0.7171717171717172,0.7272727272727273,0.7373737373737375,0.7474747474747475,0.7575757575757577,0.7676767676767677,0.7777777777777778,0.787878787878788,0.797979797979798,0.8080808080808082,0.8181818181818182,0.8282828282828284,0.8383838383838385,0.8484848484848485,0.8585858585858587,0.8686868686868687,0.8787878787878789,0.888888888888889,0.8989898989898991,0.9090909090909092,0.9191919191919192,0.9292929292929294,0.9393939393939394,0.9494949494949496,0.9595959595959597,0.9696969696969697,0.9797979797979799,0.98989898989899,1.0],\"xaxis\":\"x\",\"y\":[0.0,0.03172793349806765,0.0634239196565645,0.09505604330418266,0.12659245357374926,0.15800139597334992,0.1892512443604102,0.22031053278654067,0.2511479871810792,0.28173255684142967,0.3120334456984871,0.34202014332566877,0.3716624556603275,0.4009305354066137,0.4297949120891717,0.4582265217274104,0.4861967361004687,0.5136773915734064,0.5406408174555976,0.5670598638627707,0.5929079290546405,0.6181589862206052,0.6427876096865394,0.6667690005162916,0.6900790114821119,0.7126941713788629,0.7345917086575333,0.7557495743542583,0.7761464642917569,0.7957618405308321,0.8145759520503357,0.8325698546347714,0.8497254299495144,0.8660254037844387,0.8814533634475821,0.8959937742913359,0.9096319953545183,0.9223542941045815,0.9341478602651067,0.9450008187146685,0.954902241444074,0.963842158559942,0.9718115683235417,0.9788024462147787,0.9848077530122081,0.9898214418809327,0.9938384644612541,0.9968547759519424,0.998867339183008,0.9998741276738751,0.9998741276738751,0.998867339183008,0.9968547759519424,0.9938384644612541,0.9898214418809327,0.984807753012208,0.9788024462147786,0.9718115683235417,0.9638421585599422,0.9549022414440739,0.9450008187146685,0.9341478602651067,0.9223542941045814,0.9096319953545182,0.8959937742913359,0.8814533634475821,0.8660254037844385,0.8497254299495143,0.8325698546347712,0.8145759520503358,0.795761840530832,0.7761464642917568,0.7557495743542583,0.7345917086575331,0.7126941713788627,0.6900790114821119,0.6667690005162917,0.6427876096865395,0.6181589862206051,0.5929079290546404,0.5670598638627704,0.5406408174555974,0.5136773915734063,0.4861967361004687,0.4582265217274105,0.4297949120891714,0.4009305354066136,0.37166245566032713,0.3420201433256685,0.31203344569848696,0.28173255684142967,0.2511479871810793,0.22031053278654036,0.18925124436041008,0.15800139597334945,0.12659245357374938,0.09505604330418288,0.0634239196565644,0.031727933498067656,1.2246467991473532e-16],\"yaxis\":\"y\",\"type\":\"scatter\"},{\"legendgroup\":\"Numerical solution\",\"line\":{\"color\":\"blue\",\"dash\":\"solid\"},\"marker\":{\"symbol\":\"circle\"},\"mode\":\"lines\",\"name\":\"Numerical solution\",\"orientation\":\"v\",\"showlegend\":true,\"x\":[0.0,0.010101010101010102,0.020202020202020204,0.030303030303030304,0.04040404040404041,0.05050505050505051,0.06060606060606061,0.07070707070707072,0.08080808080808081,0.09090909090909091,0.10101010101010102,0.11111111111111112,0.12121212121212122,0.13131313131313133,0.14141414141414144,0.15151515151515152,0.16161616161616163,0.17171717171717174,0.18181818181818182,0.19191919191919193,0.20202020202020204,0.21212121212121213,0.22222222222222224,0.23232323232323235,0.24242424242424243,0.25252525252525254,0.26262626262626265,0.27272727272727276,0.2828282828282829,0.29292929292929293,0.30303030303030304,0.31313131313131315,0.32323232323232326,0.33333333333333337,0.3434343434343435,0.3535353535353536,0.36363636363636365,0.37373737373737376,0.38383838383838387,0.393939393939394,0.4040404040404041,0.4141414141414142,0.42424242424242425,0.43434343434343436,0.4444444444444445,0.4545454545454546,0.4646464646464647,0.4747474747474748,0.48484848484848486,0.494949494949495,0.5050505050505051,0.5151515151515152,0.5252525252525253,0.5353535353535354,0.5454545454545455,0.5555555555555556,0.5656565656565657,0.5757575757575758,0.5858585858585859,0.595959595959596,0.6060606060606061,0.6161616161616162,0.6262626262626263,0.6363636363636365,0.6464646464646465,0.6565656565656566,0.6666666666666667,0.6767676767676768,0.686868686868687,0.696969696969697,0.7070707070707072,0.7171717171717172,0.7272727272727273,0.7373737373737375,0.7474747474747475,0.7575757575757577,0.7676767676767677,0.7777777777777778,0.787878787878788,0.797979797979798,0.8080808080808082,0.8181818181818182,0.8282828282828284,0.8383838383838385,0.8484848484848485,0.8585858585858587,0.8686868686868687,0.8787878787878789,0.888888888888889,0.8989898989898991,0.9090909090909092,0.9191919191919192,0.9292929292929294,0.9393939393939394,0.9494949494949496,0.9595959595959597,0.9696969696969697,0.9797979797979799,0.98989898989899,1.0],\"xaxis\":\"x\",\"y\":[0.0,0.02620845649638624,0.05241691299277244,0.07862536948915867,0.10483382598554487,0.13104228248193112,0.15725073897831726,0.18345919547470355,0.2096676519710897,0.23587610846747598,0.26208456496386223,0.28829302146024843,0.3145014779566346,0.3407099344530209,0.3669183909494071,0.3931268474457933,0.4193353039421795,0.44554376043856575,0.47175221693495195,0.49796067343133815,0.5241691299277245,0.5503775864241106,0.5765860429204969,0.602794499416883,0.6290029559132692,0.6552114124096555,0.6814198689060418,0.7076283254024279,0.7338367818988142,0.7600452383952003,0.7862536948915866,0.8124621513879727,0.838670607884359,0.864879064380745,0.8648790643807451,0.8648790643807451,0.8648790643807451,0.8648790643807451,0.8648790643807451,0.8648790643807451,0.8648790643807451,0.8648790643807451,0.8648790643807451,0.8648790643807451,0.8648790643807451,0.8648790643807452,0.8648790643807452,0.8648790643807452,0.8648790643807451,0.8648790643807451,0.8648790643807451,0.8648790643807451,0.8648790643807451,0.8648790643807451,0.8648790643807452,0.8648790643807451,0.8648790643807451,0.8648790643807452,0.8648790643807451,0.8648790643807452,0.8648790643807451,0.8648790643807451,0.8648790643807452,0.8648790643807452,0.8648790643807452,0.8648790643807452,0.8648790643807449,0.8386706078843589,0.8124621513879725,0.7862536948915865,0.7600452383952,0.7338367818988139,0.7076283254024278,0.6814198689060414,0.6552114124096553,0.6290029559132689,0.6027944994168828,0.5765860429204968,0.5503775864241103,0.5241691299277244,0.49796067343133793,0.47175221693495173,0.44554376043856536,0.41933530394217916,0.39312684744579335,0.3669183909494069,0.34070993445302056,0.3145014779566342,0.2882930214602484,0.26208456496386195,0.2358761084674756,0.20966765197108972,0.18345919547470338,0.15725073897831698,0.13104228248193056,0.10483382598554479,0.07862536948915835,0.052416912992772006,0.02620845649638615,0.0],\"yaxis\":\"y\",\"type\":\"scatter\"}], {\"template\":{\"data\":{\"histogram2dcontour\":[{\"type\":\"histogram2dcontour\",\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"},\"colorscale\":[[0.0,\"#0d0887\"],[0.1111111111111111,\"#46039f\"],[0.2222222222222222,\"#7201a8\"],[0.3333333333333333,\"#9c179e\"],[0.4444444444444444,\"#bd3786\"],[0.5555555555555556,\"#d8576b\"],[0.6666666666666666,\"#ed7953\"],[0.7777777777777778,\"#fb9f3a\"],[0.8888888888888888,\"#fdca26\"],[1.0,\"#f0f921\"]]}],\"choropleth\":[{\"type\":\"choropleth\",\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}],\"histogram2d\":[{\"type\":\"histogram2d\",\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"},\"colorscale\":[[0.0,\"#0d0887\"],[0.1111111111111111,\"#46039f\"],[0.2222222222222222,\"#7201a8\"],[0.3333333333333333,\"#9c179e\"],[0.4444444444444444,\"#bd3786\"],[0.5555555555555556,\"#d8576b\"],[0.6666666666666666,\"#ed7953\"],[0.7777777777777778,\"#fb9f3a\"],[0.8888888888888888,\"#fdca26\"],[1.0,\"#f0f921\"]]}],\"heatmap\":[{\"type\":\"heatmap\",\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"},\"colorscale\":[[0.0,\"#0d0887\"],[0.1111111111111111,\"#46039f\"],[0.2222222222222222,\"#7201a8\"],[0.3333333333333333,\"#9c179e\"],[0.4444444444444444,\"#bd3786\"],[0.5555555555555556,\"#d8576b\"],[0.6666666666666666,\"#ed7953\"],[0.7777777777777778,\"#fb9f3a\"],[0.8888888888888888,\"#fdca26\"],[1.0,\"#f0f921\"]]}],\"heatmapgl\":[{\"type\":\"heatmapgl\",\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"},\"colorscale\":[[0.0,\"#0d0887\"],[0.1111111111111111,\"#46039f\"],[0.2222222222222222,\"#7201a8\"],[0.3333333333333333,\"#9c179e\"],[0.4444444444444444,\"#bd3786\"],[0.5555555555555556,\"#d8576b\"],[0.6666666666666666,\"#ed7953\"],[0.7777777777777778,\"#fb9f3a\"],[0.8888888888888888,\"#fdca26\"],[1.0,\"#f0f921\"]]}],\"contourcarpet\":[{\"type\":\"contourcarpet\",\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}],\"contour\":[{\"type\":\"contour\",\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"},\"colorscale\":[[0.0,\"#0d0887\"],[0.1111111111111111,\"#46039f\"],[0.2222222222222222,\"#7201a8\"],[0.3333333333333333,\"#9c179e\"],[0.4444444444444444,\"#bd3786\"],[0.5555555555555556,\"#d8576b\"],[0.6666666666666666,\"#ed7953\"],[0.7777777777777778,\"#fb9f3a\"],[0.8888888888888888,\"#fdca26\"],[1.0,\"#f0f921\"]]}],\"surface\":[{\"type\":\"surface\",\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"},\"colorscale\":[[0.0,\"#0d0887\"],[0.1111111111111111,\"#46039f\"],[0.2222222222222222,\"#7201a8\"],[0.3333333333333333,\"#9c179e\"],[0.4444444444444444,\"#bd3786\"],[0.5555555555555556,\"#d8576b\"],[0.6666666666666666,\"#ed7953\"],[0.7777777777777778,\"#fb9f3a\"],[0.8888888888888888,\"#fdca26\"],[1.0,\"#f0f921\"]]}],\"mesh3d\":[{\"type\":\"mesh3d\",\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}],\"scatter\":[{\"fillpattern\":{\"fillmode\":\"overlay\",\"size\":10,\"solidity\":0.2},\"type\":\"scatter\"}],\"parcoords\":[{\"type\":\"parcoords\",\"line\":{\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}}],\"scatterpolargl\":[{\"type\":\"scatterpolargl\",\"marker\":{\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}}],\"bar\":[{\"error_x\":{\"color\":\"#2a3f5f\"},\"error_y\":{\"color\":\"#2a3f5f\"},\"marker\":{\"line\":{\"color\":\"#E5ECF6\",\"width\":0.5},\"pattern\":{\"fillmode\":\"overlay\",\"size\":10,\"solidity\":0.2}},\"type\":\"bar\"}],\"scattergeo\":[{\"type\":\"scattergeo\",\"marker\":{\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}}],\"scatterpolar\":[{\"type\":\"scatterpolar\",\"marker\":{\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}}],\"histogram\":[{\"marker\":{\"pattern\":{\"fillmode\":\"overlay\",\"size\":10,\"solidity\":0.2}},\"type\":\"histogram\"}],\"scattergl\":[{\"type\":\"scattergl\",\"marker\":{\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}}],\"scatter3d\":[{\"type\":\"scatter3d\",\"line\":{\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}},\"marker\":{\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}}],\"scattermapbox\":[{\"type\":\"scattermapbox\",\"marker\":{\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}}],\"scatterternary\":[{\"type\":\"scatterternary\",\"marker\":{\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}}],\"scattercarpet\":[{\"type\":\"scattercarpet\",\"marker\":{\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}}],\"carpet\":[{\"aaxis\":{\"endlinecolor\":\"#2a3f5f\",\"gridcolor\":\"white\",\"linecolor\":\"white\",\"minorgridcolor\":\"white\",\"startlinecolor\":\"#2a3f5f\"},\"baxis\":{\"endlinecolor\":\"#2a3f5f\",\"gridcolor\":\"white\",\"linecolor\":\"white\",\"minorgridcolor\":\"white\",\"startlinecolor\":\"#2a3f5f\"},\"type\":\"carpet\"}],\"table\":[{\"cells\":{\"fill\":{\"color\":\"#EBF0F8\"},\"line\":{\"color\":\"white\"}},\"header\":{\"fill\":{\"color\":\"#C8D4E3\"},\"line\":{\"color\":\"white\"}},\"type\":\"table\"}],\"barpolar\":[{\"marker\":{\"line\":{\"color\":\"#E5ECF6\",\"width\":0.5},\"pattern\":{\"fillmode\":\"overlay\",\"size\":10,\"solidity\":0.2}},\"type\":\"barpolar\"}],\"pie\":[{\"automargin\":true,\"type\":\"pie\"}]},\"layout\":{\"autotypenumbers\":\"strict\",\"colorway\":[\"#636efa\",\"#EF553B\",\"#00cc96\",\"#ab63fa\",\"#FFA15A\",\"#19d3f3\",\"#FF6692\",\"#B6E880\",\"#FF97FF\",\"#FECB52\"],\"font\":{\"color\":\"#2a3f5f\"},\"hovermode\":\"closest\",\"hoverlabel\":{\"align\":\"left\"},\"paper_bgcolor\":\"white\",\"plot_bgcolor\":\"#E5ECF6\",\"polar\":{\"bgcolor\":\"#E5ECF6\",\"angularaxis\":{\"gridcolor\":\"white\",\"linecolor\":\"white\",\"ticks\":\"\"},\"radialaxis\":{\"gridcolor\":\"white\",\"linecolor\":\"white\",\"ticks\":\"\"}},\"ternary\":{\"bgcolor\":\"#E5ECF6\",\"aaxis\":{\"gridcolor\":\"white\",\"linecolor\":\"white\",\"ticks\":\"\"},\"baxis\":{\"gridcolor\":\"white\",\"linecolor\":\"white\",\"ticks\":\"\"},\"caxis\":{\"gridcolor\":\"white\",\"linecolor\":\"white\",\"ticks\":\"\"}},\"coloraxis\":{\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}},\"colorscale\":{\"sequential\":[[0.0,\"#0d0887\"],[0.1111111111111111,\"#46039f\"],[0.2222222222222222,\"#7201a8\"],[0.3333333333333333,\"#9c179e\"],[0.4444444444444444,\"#bd3786\"],[0.5555555555555556,\"#d8576b\"],[0.6666666666666666,\"#ed7953\"],[0.7777777777777778,\"#fb9f3a\"],[0.8888888888888888,\"#fdca26\"],[1.0,\"#f0f921\"]],\"sequentialminus\":[[0.0,\"#0d0887\"],[0.1111111111111111,\"#46039f\"],[0.2222222222222222,\"#7201a8\"],[0.3333333333333333,\"#9c179e\"],[0.4444444444444444,\"#bd3786\"],[0.5555555555555556,\"#d8576b\"],[0.6666666666666666,\"#ed7953\"],[0.7777777777777778,\"#fb9f3a\"],[0.8888888888888888,\"#fdca26\"],[1.0,\"#f0f921\"]],\"diverging\":[[0,\"#8e0152\"],[0.1,\"#c51b7d\"],[0.2,\"#de77ae\"],[0.3,\"#f1b6da\"],[0.4,\"#fde0ef\"],[0.5,\"#f7f7f7\"],[0.6,\"#e6f5d0\"],[0.7,\"#b8e186\"],[0.8,\"#7fbc41\"],[0.9,\"#4d9221\"],[1,\"#276419\"]]},\"xaxis\":{\"gridcolor\":\"white\",\"linecolor\":\"white\",\"ticks\":\"\",\"title\":{\"standoff\":15},\"zerolinecolor\":\"white\",\"automargin\":true,\"zerolinewidth\":2},\"yaxis\":{\"gridcolor\":\"white\",\"linecolor\":\"white\",\"ticks\":\"\",\"title\":{\"standoff\":15},\"zerolinecolor\":\"white\",\"automargin\":true,\"zerolinewidth\":2},\"scene\":{\"xaxis\":{\"backgroundcolor\":\"#E5ECF6\",\"gridcolor\":\"white\",\"linecolor\":\"white\",\"showbackground\":true,\"ticks\":\"\",\"zerolinecolor\":\"white\",\"gridwidth\":2},\"yaxis\":{\"backgroundcolor\":\"#E5ECF6\",\"gridcolor\":\"white\",\"linecolor\":\"white\",\"showbackground\":true,\"ticks\":\"\",\"zerolinecolor\":\"white\",\"gridwidth\":2},\"zaxis\":{\"backgroundcolor\":\"#E5ECF6\",\"gridcolor\":\"white\",\"linecolor\":\"white\",\"showbackground\":true,\"ticks\":\"\",\"zerolinecolor\":\"white\",\"gridwidth\":2}},\"shapedefaults\":{\"line\":{\"color\":\"#2a3f5f\"}},\"annotationdefaults\":{\"arrowcolor\":\"#2a3f5f\",\"arrowhead\":0,\"arrowwidth\":1},\"geo\":{\"bgcolor\":\"white\",\"landcolor\":\"#E5ECF6\",\"subunitcolor\":\"white\",\"showland\":true,\"showlakes\":true,\"lakecolor\":\"white\"},\"title\":{\"x\":0.05},\"mapbox\":{\"style\":\"light\"}}},\"xaxis\":{\"anchor\":\"y\",\"domain\":[0.0,1.0],\"title\":{\"text\":\"x\"}},\"yaxis\":{\"anchor\":\"x\",\"domain\":[0.0,1.0],\"title\":{\"text\":\"value\"}},\"legend\":{\"title\":{\"text\":\"variable\"},\"tracegroupgap\":0},\"title\":{\"text\":\"Manufactured solution of Poisson's equation\"},\"hovermode\":\"x\",\"autosize\":false,\"width\":800,\"height\":500}, {\"responsive\": true} ).then(function(){ var gd = document.getElementById('9795c319-ae78-4999-8578-d00e1dfa8c61'); var x = new MutationObserver(function (mutations, observer) {{ var display = window.getComputedStyle(gd).display; if (!display || display === 'none') {{ console.log([gd, 'removed!']); Plotly.purge(gd); observer.disconnect(); }} }}); // Listen for the removal of the full notebook cells var notebookContainer = gd.closest('#notebook-container'); if (notebookContainer) {{ x.observe(notebookContainer, {childList: true}); }} // Listen for the clearing of the current output cell var outputEl = gd.closest('.output'); if (outputEl) {{ x.observe(outputEl, {childList: true}); }} }) }; });","title":"1_linear_poisson.md"},{"location":"2_notebooks/day-1/tutorials/1_linear_poisson/#poissons-equation","text":"Welcome to this FEniCS tutorial, where we will explore how to verify the accuracy of a Poisson's equation solver using the \"manufactured solution\" technique. FEniCS is a powerful open-source finite element library for solving partial differential equations (PDEs), widely used for scientific computing and simulation. The \"manufactured solution\" approach is a valuable method to validate the correctness of finite element implementations. In this technique, we first construct an exact solution to the PDE, often a smooth and analytically known function, that satisfies the given equation. Next, we compute the corresponding right-hand side of the PDE using the exact solution. By feeding the manufactured solution and the derived right-hand side into our FEniCS solver, we can compare the numerical solution with the exact solution, thus quantifying the solver's accuracy. In this tutorial, we will focus on solving the one-dimensional Poisson's equation: \\[\\begin{split}- \\nabla^{2} u &= f \\quad {\\rm in} \\ \\Omega, \\\\ u &= 0 \\quad {\\rm on} \\ \\Gamma_{D}, \\\\ \\nabla u \\cdot n &= g \\quad {\\rm on} \\ \\Gamma_{N}. \\\\\\end{split} \\] subject to homogeneous Dirichlet boundary conditions, where u(x) is the unknown function, and f(x) is the right-hand side. We will construct a simple manufactured solution, u_exact(x), and calculate the corresponding f(x) that satisfies the equation. Throughout the tutorial, we will cover the following steps: Importing the necessary modules. Defining the manufactured solution and its corresponding right-hand side. Creating the one-dimensional mesh using FEniCS. Defining the appropriate FunctionSpace for the problem. Imposing the homogeneous Dirichlet boundary conditions. Formulating the variational problem using FEniCS's TrialFunction and TestFunction. Solving the Poisson's equation using FEniCS's solve function. Comparing the numerical solution with the exact solution to quantify the solver's accuracy. By the end of this tutorial, you will have a better understanding of the manufactured solution technique, its importance in validating finite element solvers, and how to implement it using FEniCS on an interval mesh. So, let's get started with our journey into the world - of FEniCS and manufactured solutions!","title":"Poissons Equation"},{"location":"2_notebooks/day-1/tutorials/1_linear_poisson/#step-1-import-the-necessary-modules","text":"from dolfin import * import numpy as np import matplotlib.pyplot as plt % matplotlib inline","title":"Step 1: Import the necessary modules"},{"location":"2_notebooks/day-1/tutorials/1_linear_poisson/#step-2-define-the-mesh","text":"# Create the mesh num_elements = 3 # num_elements equally spaced intervals in [0, 1] mesh = IntervalMesh ( num_elements , 0 , 1 ) plot ( mesh ) [<matplotlib.lines.Line2D at 0x7f9f10e6d4e0>]","title":"Step 2: Define the mesh"},{"location":"2_notebooks/day-1/tutorials/1_linear_poisson/#step-3-define-the-function-space","text":"The line of code U = FunctionSpace(mesh, \"CG\", 1) in FEniCS creates a function space U based on linear continuous elements ( CG ) defined on the mesh with degree 1 polynomial approximation. U = FunctionSpace ( mesh , \"CG\" , 1 )","title":"Step 3: Define the function space"},{"location":"2_notebooks/day-1/tutorials/1_linear_poisson/#step-4-define-boundary-condition","text":"We create a DirichletBC object ( bc ) that associates the function space U with the boundary condition u_D and the subdomain boundary . This means that the solution function u_sol will have the value 0.0 on the boundary of the domain during the solution of the PDE . u_D = Constant ( 0.0 ) boundary = CompiledSubDomain ( \"on_boundary\" ) bc = DirichletBC ( U , u_D , boundary )","title":"Step 4: Define boundary condition"},{"location":"2_notebooks/day-1/tutorials/1_linear_poisson/#step-5-define-weak-form","text":"\\[a(u, v) = L(v) \\quad \\forall \\ v \\in V,$$ $$\\begin{split}a(u, v) &= \\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, {\\rm d} x, \\\\ L(v) &= \\int_{\\Omega} f v \\, {\\rm d} x.\\end{split}\\] u = TrialFunction ( U ) v = TestFunction ( U ) a = inner ( grad ( u ), grad ( v )) * dx","title":"Step 5: Define weak form"},{"location":"2_notebooks/day-1/tutorials/1_linear_poisson/#step-51-define-the-manufactured-rhs","text":"For this tutorial, let's choose a simple manufactured solution. We will solve the Poisson's equation in 1D: \\[-\\Delta u(x) = f(x), 0 < x < 1,\\] where u(x) is the unknown function, and f(x) is the right-hand side. We will choose an analytical solution u_exact(x) that satisfies the above equation. For this example, let's take: \\[u_{exact}(x) = sin(\\pi x)\\] and calculate the corresponding f(x): \\[f(x) = -\\Delta u_{exact}(x) = \\pi^2 sin(\\pi x)\\] f_expr = Expression ( \"pi*pi*sin(pi*x[0])\" , pi = np . pi , degree = 2 )","title":"Step 5.1: Define the manufactured rhs"},{"location":"2_notebooks/day-1/tutorials/1_linear_poisson/#visualize-expression","text":"In the given code snippet: V = FunctionSpace(mesh, 'CG', 1) : We create a function space V defined on the provided mesh. The function space is based on continuous Galerkin (CG) elements and uses a polynomial degree of 1 for the basis functions. This means that functions in V will be represented as piecewise linear continuous functions over each element of the mesh. f_val = project(f_expr, V) : We use the project function to interpolate the expression f_expr onto the function space V . This creates a new function f_val that represents the projection of the expression f_expr onto the space V . The project function is useful when we want to create functions from Expression and visualize them. V = FunctionSpace ( mesh , 'CG' , 1 ) f_val = project ( f_expr , V ) plt . plot ([ f_val ( x ) for x in np . linspace ( 0 , 1 , 100 )]) [<matplotlib.lines.Line2D at 0x7f9ee473ad68>] L = f_expr * v * dx","title":"Visualize Expression"},{"location":"2_notebooks/day-1/tutorials/1_linear_poisson/#compute-the-solution","text":"u_sol = Function ( U ) solve ( a == L , u_sol , bc ) plot ( u_sol ) [<matplotlib.lines.Line2D at 0x7f9ee3061588>] You can pass the co-ordinates of any point inside the mesh to get the value of any FEniCS function at that point u_sol ( 0.5 ) 0.8648790643807451","title":"Compute the solution"},{"location":"2_notebooks/day-1/tutorials/1_linear_poisson/#post-processing","text":"def u_exact ( x ): return np . sin ( np . pi * x ) points = np . linspace ( 0 , 1 , 100 ) # Evaluate the exact solution at the mesh points u_exact_values = np . array ([ u_exact ( x ) for x in points ]) # Evaluate the numerical solution at the mesh points u_numerical_values = np . array ([ u_sol ( x ) for x in points ]) # Compute the error error = u_exact_values - u_numerical_values print ( \"L2 error:\" , np . linalg . norm ( error )) L2 error: 0.6951127497810745 plt . figure () plt . plot ( points , u_exact_values , \"--\" , label = 'Exact solution' , linewidth = 3 ) plt . plot ( points , u_numerical_values , label = 'Numerical solution' ) plt . xlabel ( 'x' ) plt . ylabel ( 'u(x)' ) plt . legend () plt . title ( 'Manufactured solution of Poisson \\' s equation' ) plt . grid () plt . show () !pip install plotly import plotly.express as px # Convert mesh coordinates and solutions to DataFrame for Plotly Express import pandas as pd data = pd . DataFrame ({ 'x' : points , 'Exact solution' : [ u_exact ( x ) for x in points ], 'Numerical solution' : [ u_sol ( x ) for x in points ]}) # Create a Plotly Express figure with colors specified fig = px . line ( data , x = 'x' , y = [ 'Exact solution' , 'Numerical solution' ], title = 'Manufactured solution of Poisson \\' s equation' , color_discrete_map = { 'Exact solution' : 'black' , 'Numerical solution' : 'blue' }) fig . update_traces ( mode = \"lines\" , hovertemplate = None ) # Set the figure size to achieve a 1:1 aspect ratio fig . update_layout ( hovermode = 'x' , autosize = False , width = 800 , # You can adjust this value to get the desired aspect ratio height = 500 ) # Show the Plotly Express figure fig . show () require([\"plotly\"], function(Plotly) { window.PLOTLYENV=window.PLOTLYENV || {}; if (document.getElementById(\"9795c319-ae78-4999-8578-d00e1dfa8c61\")) { Plotly.newPlot( \"9795c319-ae78-4999-8578-d00e1dfa8c61\", [{\"legendgroup\":\"Exact solution\",\"line\":{\"color\":\"black\",\"dash\":\"solid\"},\"marker\":{\"symbol\":\"circle\"},\"mode\":\"lines\",\"name\":\"Exact solution\",\"orientation\":\"v\",\"showlegend\":true,\"x\":[0.0,0.010101010101010102,0.020202020202020204,0.030303030303030304,0.04040404040404041,0.05050505050505051,0.06060606060606061,0.07070707070707072,0.08080808080808081,0.09090909090909091,0.10101010101010102,0.11111111111111112,0.12121212121212122,0.13131313131313133,0.14141414141414144,0.15151515151515152,0.16161616161616163,0.17171717171717174,0.18181818181818182,0.19191919191919193,0.20202020202020204,0.21212121212121213,0.22222222222222224,0.23232323232323235,0.24242424242424243,0.25252525252525254,0.26262626262626265,0.27272727272727276,0.2828282828282829,0.29292929292929293,0.30303030303030304,0.31313131313131315,0.32323232323232326,0.33333333333333337,0.3434343434343435,0.3535353535353536,0.36363636363636365,0.37373737373737376,0.38383838383838387,0.393939393939394,0.4040404040404041,0.4141414141414142,0.42424242424242425,0.43434343434343436,0.4444444444444445,0.4545454545454546,0.4646464646464647,0.4747474747474748,0.48484848484848486,0.494949494949495,0.5050505050505051,0.5151515151515152,0.5252525252525253,0.5353535353535354,0.5454545454545455,0.5555555555555556,0.5656565656565657,0.5757575757575758,0.5858585858585859,0.595959595959596,0.6060606060606061,0.6161616161616162,0.6262626262626263,0.6363636363636365,0.6464646464646465,0.6565656565656566,0.6666666666666667,0.6767676767676768,0.686868686868687,0.696969696969697,0.7070707070707072,0.7171717171717172,0.7272727272727273,0.7373737373737375,0.7474747474747475,0.7575757575757577,0.7676767676767677,0.7777777777777778,0.787878787878788,0.797979797979798,0.8080808080808082,0.8181818181818182,0.8282828282828284,0.8383838383838385,0.8484848484848485,0.8585858585858587,0.8686868686868687,0.8787878787878789,0.888888888888889,0.8989898989898991,0.9090909090909092,0.9191919191919192,0.9292929292929294,0.9393939393939394,0.9494949494949496,0.9595959595959597,0.9696969696969697,0.9797979797979799,0.98989898989899,1.0],\"xaxis\":\"x\",\"y\":[0.0,0.03172793349806765,0.0634239196565645,0.09505604330418266,0.12659245357374926,0.15800139597334992,0.1892512443604102,0.22031053278654067,0.2511479871810792,0.28173255684142967,0.3120334456984871,0.34202014332566877,0.3716624556603275,0.4009305354066137,0.4297949120891717,0.4582265217274104,0.4861967361004687,0.5136773915734064,0.5406408174555976,0.5670598638627707,0.5929079290546405,0.6181589862206052,0.6427876096865394,0.6667690005162916,0.6900790114821119,0.7126941713788629,0.7345917086575333,0.7557495743542583,0.7761464642917569,0.7957618405308321,0.8145759520503357,0.8325698546347714,0.8497254299495144,0.8660254037844387,0.8814533634475821,0.8959937742913359,0.9096319953545183,0.9223542941045815,0.9341478602651067,0.9450008187146685,0.954902241444074,0.963842158559942,0.9718115683235417,0.9788024462147787,0.9848077530122081,0.9898214418809327,0.9938384644612541,0.9968547759519424,0.998867339183008,0.9998741276738751,0.9998741276738751,0.998867339183008,0.9968547759519424,0.9938384644612541,0.9898214418809327,0.984807753012208,0.9788024462147786,0.9718115683235417,0.9638421585599422,0.9549022414440739,0.9450008187146685,0.9341478602651067,0.9223542941045814,0.9096319953545182,0.8959937742913359,0.8814533634475821,0.8660254037844385,0.8497254299495143,0.8325698546347712,0.8145759520503358,0.795761840530832,0.7761464642917568,0.7557495743542583,0.7345917086575331,0.7126941713788627,0.6900790114821119,0.6667690005162917,0.6427876096865395,0.6181589862206051,0.5929079290546404,0.5670598638627704,0.5406408174555974,0.5136773915734063,0.4861967361004687,0.4582265217274105,0.4297949120891714,0.4009305354066136,0.37166245566032713,0.3420201433256685,0.31203344569848696,0.28173255684142967,0.2511479871810793,0.22031053278654036,0.18925124436041008,0.15800139597334945,0.12659245357374938,0.09505604330418288,0.0634239196565644,0.031727933498067656,1.2246467991473532e-16],\"yaxis\":\"y\",\"type\":\"scatter\"},{\"legendgroup\":\"Numerical solution\",\"line\":{\"color\":\"blue\",\"dash\":\"solid\"},\"marker\":{\"symbol\":\"circle\"},\"mode\":\"lines\",\"name\":\"Numerical solution\",\"orientation\":\"v\",\"showlegend\":true,\"x\":[0.0,0.010101010101010102,0.020202020202020204,0.030303030303030304,0.04040404040404041,0.05050505050505051,0.06060606060606061,0.07070707070707072,0.08080808080808081,0.09090909090909091,0.10101010101010102,0.11111111111111112,0.12121212121212122,0.13131313131313133,0.14141414141414144,0.15151515151515152,0.16161616161616163,0.17171717171717174,0.18181818181818182,0.19191919191919193,0.20202020202020204,0.21212121212121213,0.22222222222222224,0.23232323232323235,0.24242424242424243,0.25252525252525254,0.26262626262626265,0.27272727272727276,0.2828282828282829,0.29292929292929293,0.30303030303030304,0.31313131313131315,0.32323232323232326,0.33333333333333337,0.3434343434343435,0.3535353535353536,0.36363636363636365,0.37373737373737376,0.38383838383838387,0.393939393939394,0.4040404040404041,0.4141414141414142,0.42424242424242425,0.43434343434343436,0.4444444444444445,0.4545454545454546,0.4646464646464647,0.4747474747474748,0.48484848484848486,0.494949494949495,0.5050505050505051,0.5151515151515152,0.5252525252525253,0.5353535353535354,0.5454545454545455,0.5555555555555556,0.5656565656565657,0.5757575757575758,0.5858585858585859,0.595959595959596,0.6060606060606061,0.6161616161616162,0.6262626262626263,0.6363636363636365,0.6464646464646465,0.6565656565656566,0.6666666666666667,0.6767676767676768,0.686868686868687,0.696969696969697,0.7070707070707072,0.7171717171717172,0.7272727272727273,0.7373737373737375,0.7474747474747475,0.7575757575757577,0.7676767676767677,0.7777777777777778,0.787878787878788,0.797979797979798,0.8080808080808082,0.8181818181818182,0.8282828282828284,0.8383838383838385,0.8484848484848485,0.8585858585858587,0.8686868686868687,0.8787878787878789,0.888888888888889,0.8989898989898991,0.9090909090909092,0.9191919191919192,0.9292929292929294,0.9393939393939394,0.9494949494949496,0.9595959595959597,0.9696969696969697,0.9797979797979799,0.98989898989899,1.0],\"xaxis\":\"x\",\"y\":[0.0,0.02620845649638624,0.05241691299277244,0.07862536948915867,0.10483382598554487,0.13104228248193112,0.15725073897831726,0.18345919547470355,0.2096676519710897,0.23587610846747598,0.26208456496386223,0.28829302146024843,0.3145014779566346,0.3407099344530209,0.3669183909494071,0.3931268474457933,0.4193353039421795,0.44554376043856575,0.47175221693495195,0.49796067343133815,0.5241691299277245,0.5503775864241106,0.5765860429204969,0.602794499416883,0.6290029559132692,0.6552114124096555,0.6814198689060418,0.7076283254024279,0.7338367818988142,0.7600452383952003,0.7862536948915866,0.8124621513879727,0.838670607884359,0.864879064380745,0.8648790643807451,0.8648790643807451,0.8648790643807451,0.8648790643807451,0.8648790643807451,0.8648790643807451,0.8648790643807451,0.8648790643807451,0.8648790643807451,0.8648790643807451,0.8648790643807451,0.8648790643807452,0.8648790643807452,0.8648790643807452,0.8648790643807451,0.8648790643807451,0.8648790643807451,0.8648790643807451,0.8648790643807451,0.8648790643807451,0.8648790643807452,0.8648790643807451,0.8648790643807451,0.8648790643807452,0.8648790643807451,0.8648790643807452,0.8648790643807451,0.8648790643807451,0.8648790643807452,0.8648790643807452,0.8648790643807452,0.8648790643807452,0.8648790643807449,0.8386706078843589,0.8124621513879725,0.7862536948915865,0.7600452383952,0.7338367818988139,0.7076283254024278,0.6814198689060414,0.6552114124096553,0.6290029559132689,0.6027944994168828,0.5765860429204968,0.5503775864241103,0.5241691299277244,0.49796067343133793,0.47175221693495173,0.44554376043856536,0.41933530394217916,0.39312684744579335,0.3669183909494069,0.34070993445302056,0.3145014779566342,0.2882930214602484,0.26208456496386195,0.2358761084674756,0.20966765197108972,0.18345919547470338,0.15725073897831698,0.13104228248193056,0.10483382598554479,0.07862536948915835,0.052416912992772006,0.02620845649638615,0.0],\"yaxis\":\"y\",\"type\":\"scatter\"}], {\"template\":{\"data\":{\"histogram2dcontour\":[{\"type\":\"histogram2dcontour\",\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"},\"colorscale\":[[0.0,\"#0d0887\"],[0.1111111111111111,\"#46039f\"],[0.2222222222222222,\"#7201a8\"],[0.3333333333333333,\"#9c179e\"],[0.4444444444444444,\"#bd3786\"],[0.5555555555555556,\"#d8576b\"],[0.6666666666666666,\"#ed7953\"],[0.7777777777777778,\"#fb9f3a\"],[0.8888888888888888,\"#fdca26\"],[1.0,\"#f0f921\"]]}],\"choropleth\":[{\"type\":\"choropleth\",\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}],\"histogram2d\":[{\"type\":\"histogram2d\",\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"},\"colorscale\":[[0.0,\"#0d0887\"],[0.1111111111111111,\"#46039f\"],[0.2222222222222222,\"#7201a8\"],[0.3333333333333333,\"#9c179e\"],[0.4444444444444444,\"#bd3786\"],[0.5555555555555556,\"#d8576b\"],[0.6666666666666666,\"#ed7953\"],[0.7777777777777778,\"#fb9f3a\"],[0.8888888888888888,\"#fdca26\"],[1.0,\"#f0f921\"]]}],\"heatmap\":[{\"type\":\"heatmap\",\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"},\"colorscale\":[[0.0,\"#0d0887\"],[0.1111111111111111,\"#46039f\"],[0.2222222222222222,\"#7201a8\"],[0.3333333333333333,\"#9c179e\"],[0.4444444444444444,\"#bd3786\"],[0.5555555555555556,\"#d8576b\"],[0.6666666666666666,\"#ed7953\"],[0.7777777777777778,\"#fb9f3a\"],[0.8888888888888888,\"#fdca26\"],[1.0,\"#f0f921\"]]}],\"heatmapgl\":[{\"type\":\"heatmapgl\",\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"},\"colorscale\":[[0.0,\"#0d0887\"],[0.1111111111111111,\"#46039f\"],[0.2222222222222222,\"#7201a8\"],[0.3333333333333333,\"#9c179e\"],[0.4444444444444444,\"#bd3786\"],[0.5555555555555556,\"#d8576b\"],[0.6666666666666666,\"#ed7953\"],[0.7777777777777778,\"#fb9f3a\"],[0.8888888888888888,\"#fdca26\"],[1.0,\"#f0f921\"]]}],\"contourcarpet\":[{\"type\":\"contourcarpet\",\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}],\"contour\":[{\"type\":\"contour\",\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"},\"colorscale\":[[0.0,\"#0d0887\"],[0.1111111111111111,\"#46039f\"],[0.2222222222222222,\"#7201a8\"],[0.3333333333333333,\"#9c179e\"],[0.4444444444444444,\"#bd3786\"],[0.5555555555555556,\"#d8576b\"],[0.6666666666666666,\"#ed7953\"],[0.7777777777777778,\"#fb9f3a\"],[0.8888888888888888,\"#fdca26\"],[1.0,\"#f0f921\"]]}],\"surface\":[{\"type\":\"surface\",\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"},\"colorscale\":[[0.0,\"#0d0887\"],[0.1111111111111111,\"#46039f\"],[0.2222222222222222,\"#7201a8\"],[0.3333333333333333,\"#9c179e\"],[0.4444444444444444,\"#bd3786\"],[0.5555555555555556,\"#d8576b\"],[0.6666666666666666,\"#ed7953\"],[0.7777777777777778,\"#fb9f3a\"],[0.8888888888888888,\"#fdca26\"],[1.0,\"#f0f921\"]]}],\"mesh3d\":[{\"type\":\"mesh3d\",\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}],\"scatter\":[{\"fillpattern\":{\"fillmode\":\"overlay\",\"size\":10,\"solidity\":0.2},\"type\":\"scatter\"}],\"parcoords\":[{\"type\":\"parcoords\",\"line\":{\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}}],\"scatterpolargl\":[{\"type\":\"scatterpolargl\",\"marker\":{\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}}],\"bar\":[{\"error_x\":{\"color\":\"#2a3f5f\"},\"error_y\":{\"color\":\"#2a3f5f\"},\"marker\":{\"line\":{\"color\":\"#E5ECF6\",\"width\":0.5},\"pattern\":{\"fillmode\":\"overlay\",\"size\":10,\"solidity\":0.2}},\"type\":\"bar\"}],\"scattergeo\":[{\"type\":\"scattergeo\",\"marker\":{\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}}],\"scatterpolar\":[{\"type\":\"scatterpolar\",\"marker\":{\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}}],\"histogram\":[{\"marker\":{\"pattern\":{\"fillmode\":\"overlay\",\"size\":10,\"solidity\":0.2}},\"type\":\"histogram\"}],\"scattergl\":[{\"type\":\"scattergl\",\"marker\":{\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}}],\"scatter3d\":[{\"type\":\"scatter3d\",\"line\":{\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}},\"marker\":{\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}}],\"scattermapbox\":[{\"type\":\"scattermapbox\",\"marker\":{\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}}],\"scatterternary\":[{\"type\":\"scatterternary\",\"marker\":{\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}}],\"scattercarpet\":[{\"type\":\"scattercarpet\",\"marker\":{\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}}}],\"carpet\":[{\"aaxis\":{\"endlinecolor\":\"#2a3f5f\",\"gridcolor\":\"white\",\"linecolor\":\"white\",\"minorgridcolor\":\"white\",\"startlinecolor\":\"#2a3f5f\"},\"baxis\":{\"endlinecolor\":\"#2a3f5f\",\"gridcolor\":\"white\",\"linecolor\":\"white\",\"minorgridcolor\":\"white\",\"startlinecolor\":\"#2a3f5f\"},\"type\":\"carpet\"}],\"table\":[{\"cells\":{\"fill\":{\"color\":\"#EBF0F8\"},\"line\":{\"color\":\"white\"}},\"header\":{\"fill\":{\"color\":\"#C8D4E3\"},\"line\":{\"color\":\"white\"}},\"type\":\"table\"}],\"barpolar\":[{\"marker\":{\"line\":{\"color\":\"#E5ECF6\",\"width\":0.5},\"pattern\":{\"fillmode\":\"overlay\",\"size\":10,\"solidity\":0.2}},\"type\":\"barpolar\"}],\"pie\":[{\"automargin\":true,\"type\":\"pie\"}]},\"layout\":{\"autotypenumbers\":\"strict\",\"colorway\":[\"#636efa\",\"#EF553B\",\"#00cc96\",\"#ab63fa\",\"#FFA15A\",\"#19d3f3\",\"#FF6692\",\"#B6E880\",\"#FF97FF\",\"#FECB52\"],\"font\":{\"color\":\"#2a3f5f\"},\"hovermode\":\"closest\",\"hoverlabel\":{\"align\":\"left\"},\"paper_bgcolor\":\"white\",\"plot_bgcolor\":\"#E5ECF6\",\"polar\":{\"bgcolor\":\"#E5ECF6\",\"angularaxis\":{\"gridcolor\":\"white\",\"linecolor\":\"white\",\"ticks\":\"\"},\"radialaxis\":{\"gridcolor\":\"white\",\"linecolor\":\"white\",\"ticks\":\"\"}},\"ternary\":{\"bgcolor\":\"#E5ECF6\",\"aaxis\":{\"gridcolor\":\"white\",\"linecolor\":\"white\",\"ticks\":\"\"},\"baxis\":{\"gridcolor\":\"white\",\"linecolor\":\"white\",\"ticks\":\"\"},\"caxis\":{\"gridcolor\":\"white\",\"linecolor\":\"white\",\"ticks\":\"\"}},\"coloraxis\":{\"colorbar\":{\"outlinewidth\":0,\"ticks\":\"\"}},\"colorscale\":{\"sequential\":[[0.0,\"#0d0887\"],[0.1111111111111111,\"#46039f\"],[0.2222222222222222,\"#7201a8\"],[0.3333333333333333,\"#9c179e\"],[0.4444444444444444,\"#bd3786\"],[0.5555555555555556,\"#d8576b\"],[0.6666666666666666,\"#ed7953\"],[0.7777777777777778,\"#fb9f3a\"],[0.8888888888888888,\"#fdca26\"],[1.0,\"#f0f921\"]],\"sequentialminus\":[[0.0,\"#0d0887\"],[0.1111111111111111,\"#46039f\"],[0.2222222222222222,\"#7201a8\"],[0.3333333333333333,\"#9c179e\"],[0.4444444444444444,\"#bd3786\"],[0.5555555555555556,\"#d8576b\"],[0.6666666666666666,\"#ed7953\"],[0.7777777777777778,\"#fb9f3a\"],[0.8888888888888888,\"#fdca26\"],[1.0,\"#f0f921\"]],\"diverging\":[[0,\"#8e0152\"],[0.1,\"#c51b7d\"],[0.2,\"#de77ae\"],[0.3,\"#f1b6da\"],[0.4,\"#fde0ef\"],[0.5,\"#f7f7f7\"],[0.6,\"#e6f5d0\"],[0.7,\"#b8e186\"],[0.8,\"#7fbc41\"],[0.9,\"#4d9221\"],[1,\"#276419\"]]},\"xaxis\":{\"gridcolor\":\"white\",\"linecolor\":\"white\",\"ticks\":\"\",\"title\":{\"standoff\":15},\"zerolinecolor\":\"white\",\"automargin\":true,\"zerolinewidth\":2},\"yaxis\":{\"gridcolor\":\"white\",\"linecolor\":\"white\",\"ticks\":\"\",\"title\":{\"standoff\":15},\"zerolinecolor\":\"white\",\"automargin\":true,\"zerolinewidth\":2},\"scene\":{\"xaxis\":{\"backgroundcolor\":\"#E5ECF6\",\"gridcolor\":\"white\",\"linecolor\":\"white\",\"showbackground\":true,\"ticks\":\"\",\"zerolinecolor\":\"white\",\"gridwidth\":2},\"yaxis\":{\"backgroundcolor\":\"#E5ECF6\",\"gridcolor\":\"white\",\"linecolor\":\"white\",\"showbackground\":true,\"ticks\":\"\",\"zerolinecolor\":\"white\",\"gridwidth\":2},\"zaxis\":{\"backgroundcolor\":\"#E5ECF6\",\"gridcolor\":\"white\",\"linecolor\":\"white\",\"showbackground\":true,\"ticks\":\"\",\"zerolinecolor\":\"white\",\"gridwidth\":2}},\"shapedefaults\":{\"line\":{\"color\":\"#2a3f5f\"}},\"annotationdefaults\":{\"arrowcolor\":\"#2a3f5f\",\"arrowhead\":0,\"arrowwidth\":1},\"geo\":{\"bgcolor\":\"white\",\"landcolor\":\"#E5ECF6\",\"subunitcolor\":\"white\",\"showland\":true,\"showlakes\":true,\"lakecolor\":\"white\"},\"title\":{\"x\":0.05},\"mapbox\":{\"style\":\"light\"}}},\"xaxis\":{\"anchor\":\"y\",\"domain\":[0.0,1.0],\"title\":{\"text\":\"x\"}},\"yaxis\":{\"anchor\":\"x\",\"domain\":[0.0,1.0],\"title\":{\"text\":\"value\"}},\"legend\":{\"title\":{\"text\":\"variable\"},\"tracegroupgap\":0},\"title\":{\"text\":\"Manufactured solution of Poisson's equation\"},\"hovermode\":\"x\",\"autosize\":false,\"width\":800,\"height\":500}, {\"responsive\": true} ).then(function(){ var gd = document.getElementById('9795c319-ae78-4999-8578-d00e1dfa8c61'); var x = new MutationObserver(function (mutations, observer) {{ var display = window.getComputedStyle(gd).display; if (!display || display === 'none') {{ console.log([gd, 'removed!']); Plotly.purge(gd); observer.disconnect(); }} }}); // Listen for the removal of the full notebook cells var notebookContainer = gd.closest('#notebook-container'); if (notebookContainer) {{ x.observe(notebookContainer, {childList: true}); }} // Listen for the clearing of the current output cell var outputEl = gd.closest('.output'); if (outputEl) {{ x.observe(outputEl, {childList: true}); }} }) }; });","title":"Post processing"},{"location":"2_notebooks/day-1/tutorials/2_visualization/","text":"Visualizing simulation results Once the simulation is performed in FEniCS and the results are obtained, this tutorial will show you how to save the output in the XDMF file format. XDMF is ideal for storing large-scale scientific data, especially for finite element simulations, thanks to its flexibility and efficiency. from dolfin import * num_elements = 30 mesh = IntervalMesh ( num_elements , 0 , 1 ) U = FunctionSpace ( mesh , \"CG\" , 1 ) u_D = Constant ( 0.0 ) boundary = CompiledSubDomain ( \"on_boundary\" ) bc = DirichletBC ( U , u_D , boundary ) u , v = TrialFunction ( U ), TestFunction ( U ) a = inner ( grad ( u ), grad ( v )) * dx f_expr = Expression ( \"pi*pi*sin(pi*x[0])\" , pi = np . pi , degree = 2 ) L = f_expr * v * dx u_sol = Function ( U , name = \"field\" ) solve ( a == L , u_sol , bc ) Option 1: Write data efficiently using with syntax. FEniCS provides us with an XDMFFile class for efficiently handling XDMF files and storing simulation results. with XDMFFile ( \"output/result.xdmf\" ) as outfile : outfile . write ( u_sol ) Let's break down the command step by step: XDMFFile : This is a class in FEniCS used to write simulation data to an XDMF file. XDMF is an XML-based file format commonly used to store scientific data, especially for finite element simulations. \"output/result.xdmf\" : This is the file path and name where the XDMF file will be created or updated. In this case, the file will be named \"result.xdmf\" and will be located in the \"output\" directory (relative to the current working directory). with : This keyword is used to define a context manager in Python. It ensures that resources associated with the context (in this case, the XDMFFile object) are properly managed and released when the block of code inside the with statement is executed. as outfile : This assigns the XDMFFile object to the variable outfile , which can be used to interact with the file and write data. outfile.write(u_sol) : This line of code writes the data u_sol to the XDMF file. u_sol is the variable containing the solution. Note that the name that is passed on to the variable during its creation is the name that will appear in the visualization tool paraview. Overall, this command creates an XDMFFile object, opens the file \"output/result.xdmf\" for writing, writes the data contained in the u_sol variable to the file, and then automatically closes the file after the code block within the with statement is executed. This allows for efficient and controlled writing of simulation results to an XDMF file, which can later be visualized using tools like Paraview to analyze and interpret the simulation data. Option 2: Use this to write data when dealing with timeseries In engineering, numerous problems demand the consideration of multiple variables and time-steps, which subsequently leads to the need for writing these variables to a file in a time series format. In such cases, FEniCS offers a convenient solution through the utilization of the XDMFFile class, facilitating efficient storage of simulation results. We can access the parameters of the XDMFFile object to control its behaviour: - functions_share_mesh : Default is false, it controls whether all functions on a single time step share the same mesh. If true the files created will be smaller and also behave better in Paraview. - rewrite_function_mesh : Default settings is true, i.e, it controls whether the mesh will be rewritten every time step. If the mesh does not change this can be turned off to create smaller files. - flush_output : Default is false, it controls the ability of Paraview to render during execution. If you are doing a time dependent analysis, setting it to true will allow you to visualize results during run. outfile = XDMFFile ( \"output/result.xdmf\" ) outfile . parameters [ \"functions_share_mesh\" ] = True outfile . parameters [ \"rewrite_function_mesh\" ] = False outfile . parameters [ \"flush_output\" ] = True time_step = 1 outfile . write ( u_sol , time_step ) outfile . close () At the end of the execution it is recommended to close the XDMFFile object.","title":"2_visualization.md"},{"location":"2_notebooks/day-1/tutorials/2_visualization/#visualizing-simulation-results","text":"Once the simulation is performed in FEniCS and the results are obtained, this tutorial will show you how to save the output in the XDMF file format. XDMF is ideal for storing large-scale scientific data, especially for finite element simulations, thanks to its flexibility and efficiency. from dolfin import * num_elements = 30 mesh = IntervalMesh ( num_elements , 0 , 1 ) U = FunctionSpace ( mesh , \"CG\" , 1 ) u_D = Constant ( 0.0 ) boundary = CompiledSubDomain ( \"on_boundary\" ) bc = DirichletBC ( U , u_D , boundary ) u , v = TrialFunction ( U ), TestFunction ( U ) a = inner ( grad ( u ), grad ( v )) * dx f_expr = Expression ( \"pi*pi*sin(pi*x[0])\" , pi = np . pi , degree = 2 ) L = f_expr * v * dx u_sol = Function ( U , name = \"field\" ) solve ( a == L , u_sol , bc )","title":"Visualizing simulation results"},{"location":"2_notebooks/day-1/tutorials/2_visualization/#option-1-write-data-efficiently-using-with-syntax","text":"FEniCS provides us with an XDMFFile class for efficiently handling XDMF files and storing simulation results. with XDMFFile ( \"output/result.xdmf\" ) as outfile : outfile . write ( u_sol ) Let's break down the command step by step: XDMFFile : This is a class in FEniCS used to write simulation data to an XDMF file. XDMF is an XML-based file format commonly used to store scientific data, especially for finite element simulations. \"output/result.xdmf\" : This is the file path and name where the XDMF file will be created or updated. In this case, the file will be named \"result.xdmf\" and will be located in the \"output\" directory (relative to the current working directory). with : This keyword is used to define a context manager in Python. It ensures that resources associated with the context (in this case, the XDMFFile object) are properly managed and released when the block of code inside the with statement is executed. as outfile : This assigns the XDMFFile object to the variable outfile , which can be used to interact with the file and write data. outfile.write(u_sol) : This line of code writes the data u_sol to the XDMF file. u_sol is the variable containing the solution. Note that the name that is passed on to the variable during its creation is the name that will appear in the visualization tool paraview. Overall, this command creates an XDMFFile object, opens the file \"output/result.xdmf\" for writing, writes the data contained in the u_sol variable to the file, and then automatically closes the file after the code block within the with statement is executed. This allows for efficient and controlled writing of simulation results to an XDMF file, which can later be visualized using tools like Paraview to analyze and interpret the simulation data.","title":"Option 1: Write data efficiently using with syntax."},{"location":"2_notebooks/day-1/tutorials/2_visualization/#option-2-use-this-to-write-data-when-dealing-with-timeseries","text":"In engineering, numerous problems demand the consideration of multiple variables and time-steps, which subsequently leads to the need for writing these variables to a file in a time series format. In such cases, FEniCS offers a convenient solution through the utilization of the XDMFFile class, facilitating efficient storage of simulation results. We can access the parameters of the XDMFFile object to control its behaviour: - functions_share_mesh : Default is false, it controls whether all functions on a single time step share the same mesh. If true the files created will be smaller and also behave better in Paraview. - rewrite_function_mesh : Default settings is true, i.e, it controls whether the mesh will be rewritten every time step. If the mesh does not change this can be turned off to create smaller files. - flush_output : Default is false, it controls the ability of Paraview to render during execution. If you are doing a time dependent analysis, setting it to true will allow you to visualize results during run. outfile = XDMFFile ( \"output/result.xdmf\" ) outfile . parameters [ \"functions_share_mesh\" ] = True outfile . parameters [ \"rewrite_function_mesh\" ] = False outfile . parameters [ \"flush_output\" ] = True time_step = 1 outfile . write ( u_sol , time_step ) outfile . close () At the end of the execution it is recommended to close the XDMFFile object.","title":"Option 2: Use this to write data when dealing with timeseries"},{"location":"2_notebooks/day-2/exercises/1_2d_3d_domains/","text":"2D and 3D domains Implement the learning of exercise-1 from day-1 to solve the non-linear Poisson's equation on 2D and 3D domains. Feel free to create the mesh of your preference for the problem. Download and install Paraview. Name the fields to be visualized. (To visualize a function in Paraview you have to name it in FEniCS. The way to do that is use the command v.rename(\"name\", \"label\") ) Write to XDMF the error and the solution. Visualize the error and solution in Paraview Hint: Check day-1/tutorial-2 from dolfin import * import numpy Update this mesh to a unit square mesh. mesh = IntervalMesh(40, 0, 1) V = FunctionSpace(mesh, 'Lagrange', 1) left_boundary = CompiledSubDomain(\"on_boundary && near(x[0],0)\") right_boundary = CompiledSubDomain(\"on_boundary && near(x[0],1)\") bc_0 = DirichletBC(V, Constant(0.0), left_boundary) bc_1 = DirichletBC(V, Constant(1.0), right_boundary) bcs = [bc_0, bc_1] m = 5 def q(u): return (1+u)**m # Define variational problem v = TestFunction(V) du = TrialFunction(V) u = Function(V) # most recently computed solution F = inner(q(u)*nabla_grad(u), nabla_grad(v))*dx J = derivative(F, u, du) # Compute solution problem = NonlinearVariationalProblem(F, u, bcs, J) solver = NonlinearVariationalSolver(problem) prm = solver.parameters prm['newton_solver']['absolute_tolerance'] = 1E-5 prm['newton_solver']['relative_tolerance'] = 1E-5 prm['newton_solver']['maximum_iterations'] = 25 solver.solve() # Find max error u_exact = Expression( 'pow((pow(2, m+1)-1)*x[0] + 1, 1.0/(m+1)) - 1', m=m, degree=1) u_e = interpolate(u_exact, V) diff = numpy.abs(u_e.vector()[:] - u.vector()[:]).max() print('Max error:{0:5.3e}'.format(diff)) Max error:2.167e-02 plot(u_e) [<matplotlib.lines.Line2D at 0x7f38e1238828>] Export the error and solution vector to XDMF","title":"1_2d_3d_domains.md"},{"location":"2_notebooks/day-2/exercises/1_2d_3d_domains/#2d-and-3d-domains","text":"Implement the learning of exercise-1 from day-1 to solve the non-linear Poisson's equation on 2D and 3D domains. Feel free to create the mesh of your preference for the problem. Download and install Paraview. Name the fields to be visualized. (To visualize a function in Paraview you have to name it in FEniCS. The way to do that is use the command v.rename(\"name\", \"label\") ) Write to XDMF the error and the solution. Visualize the error and solution in Paraview Hint: Check day-1/tutorial-2 from dolfin import * import numpy Update this mesh to a unit square mesh. mesh = IntervalMesh(40, 0, 1) V = FunctionSpace(mesh, 'Lagrange', 1) left_boundary = CompiledSubDomain(\"on_boundary && near(x[0],0)\") right_boundary = CompiledSubDomain(\"on_boundary && near(x[0],1)\") bc_0 = DirichletBC(V, Constant(0.0), left_boundary) bc_1 = DirichletBC(V, Constant(1.0), right_boundary) bcs = [bc_0, bc_1] m = 5 def q(u): return (1+u)**m # Define variational problem v = TestFunction(V) du = TrialFunction(V) u = Function(V) # most recently computed solution F = inner(q(u)*nabla_grad(u), nabla_grad(v))*dx J = derivative(F, u, du) # Compute solution problem = NonlinearVariationalProblem(F, u, bcs, J) solver = NonlinearVariationalSolver(problem) prm = solver.parameters prm['newton_solver']['absolute_tolerance'] = 1E-5 prm['newton_solver']['relative_tolerance'] = 1E-5 prm['newton_solver']['maximum_iterations'] = 25 solver.solve() # Find max error u_exact = Expression( 'pow((pow(2, m+1)-1)*x[0] + 1, 1.0/(m+1)) - 1', m=m, degree=1) u_e = interpolate(u_exact, V) diff = numpy.abs(u_e.vector()[:] - u.vector()[:]).max() print('Max error:{0:5.3e}'.format(diff)) Max error:2.167e-02 plot(u_e) [<matplotlib.lines.Line2D at 0x7f38e1238828>] Export the error and solution vector to XDMF","title":"2D and 3D domains"},{"location":"2_notebooks/day-2/exercises/2_boundary_conditions/","text":"Boundary conditions Implement the learning of exercise-2 from day-1 to solve the non-linear Poisson's equation with different boundary conditions. Feel free to create a 2D mesh of your preference for the problem and experiment with different boundary conditions. Write the results to XDMF and visualize them in PARAVIEW. See what happens to the error when you change the domain to a rectangular domain with dimensions \\(2 \\times 1\\) from dolfin import * import numpy mesh = IntervalMesh(40, 0, 1) V = FunctionSpace(mesh, 'Lagrange', 1) left_boundary = CompiledSubDomain(\"on_boundary && near(x[0],0)\") right_boundary = CompiledSubDomain(\"on_boundary && near(x[0],1)\") top_boundary = CompiledSubDomain(\"on_boundary && near(x[1],1)\") bottom_boundary = CompiledSubDomain(\"on_boundary && near(x[1],0)\") bc_0 = DirichletBC(V, Constant(0.0), left_boundary) bc_1 = DirichletBC(V, Constant(1.0), right_boundary) bcs = [bc_0, bc_1] m = 5 def q(u): return (1+u)**m # Define variational problem v = TestFunction(V) du = TrialFunction(V) u = Function(V) # most recently computed solution F = inner(q(u)*nabla_grad(u), nabla_grad(v))*dx J = derivative(F, u, du) # Compute solution problem = NonlinearVariationalProblem(F, u, bcs, J) solver = NonlinearVariationalSolver(problem) prm = solver.parameters prm['newton_solver']['absolute_tolerance'] = 1E-5 prm['newton_solver']['relative_tolerance'] = 1E-5 prm['newton_solver']['maximum_iterations'] = 25 solver.solve() (6, True) plot(u) <matplotlib.tri.tricontour.TriContourSet at 0x7f38e2ec7b70> # Find max error u_exact = Expression( 'pow((pow(2, m+1)-1)*x[0] + 1, 1.0/(m+1)) - 1', m=m, degree=1) u_e = interpolate(u_exact, V) diff = numpy.abs(u_e.vector()[:] - u.vector()[:]).max() print('Max error:{0:5.3e}'.format(diff))","title":"2_boundary_conditions.md"},{"location":"2_notebooks/day-2/exercises/2_boundary_conditions/#boundary-conditions","text":"Implement the learning of exercise-2 from day-1 to solve the non-linear Poisson's equation with different boundary conditions. Feel free to create a 2D mesh of your preference for the problem and experiment with different boundary conditions. Write the results to XDMF and visualize them in PARAVIEW. See what happens to the error when you change the domain to a rectangular domain with dimensions \\(2 \\times 1\\) from dolfin import * import numpy mesh = IntervalMesh(40, 0, 1) V = FunctionSpace(mesh, 'Lagrange', 1) left_boundary = CompiledSubDomain(\"on_boundary && near(x[0],0)\") right_boundary = CompiledSubDomain(\"on_boundary && near(x[0],1)\") top_boundary = CompiledSubDomain(\"on_boundary && near(x[1],1)\") bottom_boundary = CompiledSubDomain(\"on_boundary && near(x[1],0)\") bc_0 = DirichletBC(V, Constant(0.0), left_boundary) bc_1 = DirichletBC(V, Constant(1.0), right_boundary) bcs = [bc_0, bc_1] m = 5 def q(u): return (1+u)**m # Define variational problem v = TestFunction(V) du = TrialFunction(V) u = Function(V) # most recently computed solution F = inner(q(u)*nabla_grad(u), nabla_grad(v))*dx J = derivative(F, u, du) # Compute solution problem = NonlinearVariationalProblem(F, u, bcs, J) solver = NonlinearVariationalSolver(problem) prm = solver.parameters prm['newton_solver']['absolute_tolerance'] = 1E-5 prm['newton_solver']['relative_tolerance'] = 1E-5 prm['newton_solver']['maximum_iterations'] = 25 solver.solve() (6, True) plot(u) <matplotlib.tri.tricontour.TriContourSet at 0x7f38e2ec7b70> # Find max error u_exact = Expression( 'pow((pow(2, m+1)-1)*x[0] + 1, 1.0/(m+1)) - 1', m=m, degree=1) u_e = interpolate(u_exact, V) diff = numpy.abs(u_e.vector()[:] - u.vector()[:]).max() print('Max error:{0:5.3e}'.format(diff))","title":"Boundary conditions"},{"location":"2_notebooks/day-2/exercises/3_non_linearity_tolerances/","text":"Tolerances and convergence In numerical methods, solving non-linear problems poses unique challenges due to their intrinsic complexity. Solver design become crucial aspect to consider while tackling these problems, as they govern the accuracy and reliability of the obtained solutions. Understanding tolerance levels, which dictate the acceptable deviation between successive iterations, and convergence criteria, which indicate when a solution has reached a satisfactory result is of prime importance when handling non-linear problems. In this exercise, your task is to explore the impact of modifying three parameters: absolute tolerance, relative tolerance, and maximum iterations, on the computational cost and solution accuracy. By adjusting these parameters, you will gain insights into how they influence the numerical solution of the problem at hand. from dolfin import * import numpy mesh = IntervalMesh(40, 0, 1) V = FunctionSpace(mesh, 'Lagrange', 1) left_boundary = CompiledSubDomain(\"on_boundary && near(x[0],0)\") right_boundary = CompiledSubDomain(\"on_boundary && near(x[0],1)\") bc_0 = DirichletBC(V, Constant(0.0), left_boundary) bc_1 = DirichletBC(V, Constant(1.0), right_boundary) bcs = [bc_0, bc_1] m = 5 def q(u): return (1+u)**m # Define variational problem v = TestFunction(V) du = TrialFunction(V) u = Function(V) # most recently computed solution F = inner(q(u)*nabla_grad(u), nabla_grad(v))*dx Change the tangent modifer to a value between 0.5 and 1 and see how it affects the solution. tangent_modifier = 1 J = derivative(tangent_modifier*F, u, du) # Compute solution problem = NonlinearVariationalProblem(F, u, bcs, J) solver = NonlinearVariationalSolver(problem) Change the tolerances and maximum_iterations to see what happens to the solution in terms of computational cost and solution accuracy. prm = solver.parameters prm['newton_solver']['absolute_tolerance'] = 1E-5 prm['newton_solver']['relative_tolerance'] = 1E-5 prm['newton_solver']['maximum_iterations'] = 25 iterations, converged = solver.solve() print(\"Number of iterations: {}\".format(iterations)) print(\"The solver converged.\" if converged else \"The solver did not converge.\") Number of iterations: 6 The solver converged. # Find max error u_exact = Expression( 'pow((pow(2, m+1)-1)*x[0] + 1, 1.0/(m+1)) - 1', m=m, degree=1) u_e = interpolate(u_exact, V) diff = numpy.abs(u_e.vector()[:] - u.vector()[:]).max() print('Max error:{0:5.3e}'.format(diff)) Max error:1.559e-06","title":"3_non_linearity_tolerances.md"},{"location":"2_notebooks/day-2/exercises/3_non_linearity_tolerances/#tolerances-and-convergence","text":"In numerical methods, solving non-linear problems poses unique challenges due to their intrinsic complexity. Solver design become crucial aspect to consider while tackling these problems, as they govern the accuracy and reliability of the obtained solutions. Understanding tolerance levels, which dictate the acceptable deviation between successive iterations, and convergence criteria, which indicate when a solution has reached a satisfactory result is of prime importance when handling non-linear problems. In this exercise, your task is to explore the impact of modifying three parameters: absolute tolerance, relative tolerance, and maximum iterations, on the computational cost and solution accuracy. By adjusting these parameters, you will gain insights into how they influence the numerical solution of the problem at hand. from dolfin import * import numpy mesh = IntervalMesh(40, 0, 1) V = FunctionSpace(mesh, 'Lagrange', 1) left_boundary = CompiledSubDomain(\"on_boundary && near(x[0],0)\") right_boundary = CompiledSubDomain(\"on_boundary && near(x[0],1)\") bc_0 = DirichletBC(V, Constant(0.0), left_boundary) bc_1 = DirichletBC(V, Constant(1.0), right_boundary) bcs = [bc_0, bc_1] m = 5 def q(u): return (1+u)**m # Define variational problem v = TestFunction(V) du = TrialFunction(V) u = Function(V) # most recently computed solution F = inner(q(u)*nabla_grad(u), nabla_grad(v))*dx Change the tangent modifer to a value between 0.5 and 1 and see how it affects the solution. tangent_modifier = 1 J = derivative(tangent_modifier*F, u, du) # Compute solution problem = NonlinearVariationalProblem(F, u, bcs, J) solver = NonlinearVariationalSolver(problem) Change the tolerances and maximum_iterations to see what happens to the solution in terms of computational cost and solution accuracy. prm = solver.parameters prm['newton_solver']['absolute_tolerance'] = 1E-5 prm['newton_solver']['relative_tolerance'] = 1E-5 prm['newton_solver']['maximum_iterations'] = 25 iterations, converged = solver.solve() print(\"Number of iterations: {}\".format(iterations)) print(\"The solver converged.\" if converged else \"The solver did not converge.\") Number of iterations: 6 The solver converged. # Find max error u_exact = Expression( 'pow((pow(2, m+1)-1)*x[0] + 1, 1.0/(m+1)) - 1', m=m, degree=1) u_e = interpolate(u_exact, V) diff = numpy.abs(u_e.vector()[:] - u.vector()[:]).max() print('Max error:{0:5.3e}'.format(diff)) Max error:1.559e-06","title":"Tolerances and convergence"},{"location":"2_notebooks/day-2/exercises/4_manual_auto_differentiation/","text":"Automatic Differentiation Automatic Differentiation (AD) is a powerful computational tool that has revolutionized various fields, particularly in mathematics, physics, engineering, and machine learning. It provides a systematic and efficient way to compute derivatives of complex mathematical functions, allowing us to effortlessly obtain accurate and reliable gradients. This capability of AD brings a multitude of benefits, enabling faster and more robust optimization, enhancing the performance of machine learning models, and facilitating the solution of intricate differential equations. In this exercise you have to use both manual differentiation and automatic differentiation to find the solution of the following Poisson's equation. \\[-div(q(u)*\\Delta(u)) = 0,$$ $$u = 0\\text{ at }x=0, u=1\\text{ at }x=1$$ $$q(u) = (1+2u+4u^3)\\] from dolfin import * import numpy mesh = IntervalMesh(40, 0, 1) V = FunctionSpace(mesh, 'Lagrange', 1) left_boundary = CompiledSubDomain(\"on_boundary && near(x[0],0)\") right_boundary = CompiledSubDomain(\"on_boundary && near(x[0],1)\") bc_0 = DirichletBC(V, Constant(0.0), left_boundary) bc_1 = DirichletBC(V, Constant(1.0), right_boundary) bcs = [bc_0, bc_1] m = 2 def q(u): return (1+u)**m # Define variational problem v = TestFunction(V) du = TrialFunction(V) u = Function(V) # most recently computed solution F = inner(q(u)*nabla_grad(u), nabla_grad(v))*dx J = derivative(F, u, du) # Compute solution problem = NonlinearVariationalProblem(F, u, bcs, J) solver = NonlinearVariationalSolver(problem) prm = solver.parameters prm['newton_solver']['absolute_tolerance'] = 1E-5 prm['newton_solver']['relative_tolerance'] = 1E-5 prm['newton_solver']['maximum_iterations'] = 25 solver.solve() (4, True) plot(u) [<matplotlib.lines.Line2D at 0x7f38ee302940>]","title":"4_manual_auto_differentiation.md"},{"location":"2_notebooks/day-2/exercises/4_manual_auto_differentiation/#automatic-differentiation","text":"Automatic Differentiation (AD) is a powerful computational tool that has revolutionized various fields, particularly in mathematics, physics, engineering, and machine learning. It provides a systematic and efficient way to compute derivatives of complex mathematical functions, allowing us to effortlessly obtain accurate and reliable gradients. This capability of AD brings a multitude of benefits, enabling faster and more robust optimization, enhancing the performance of machine learning models, and facilitating the solution of intricate differential equations. In this exercise you have to use both manual differentiation and automatic differentiation to find the solution of the following Poisson's equation. \\[-div(q(u)*\\Delta(u)) = 0,$$ $$u = 0\\text{ at }x=0, u=1\\text{ at }x=1$$ $$q(u) = (1+2u+4u^3)\\] from dolfin import * import numpy mesh = IntervalMesh(40, 0, 1) V = FunctionSpace(mesh, 'Lagrange', 1) left_boundary = CompiledSubDomain(\"on_boundary && near(x[0],0)\") right_boundary = CompiledSubDomain(\"on_boundary && near(x[0],1)\") bc_0 = DirichletBC(V, Constant(0.0), left_boundary) bc_1 = DirichletBC(V, Constant(1.0), right_boundary) bcs = [bc_0, bc_1] m = 2 def q(u): return (1+u)**m # Define variational problem v = TestFunction(V) du = TrialFunction(V) u = Function(V) # most recently computed solution F = inner(q(u)*nabla_grad(u), nabla_grad(v))*dx J = derivative(F, u, du) # Compute solution problem = NonlinearVariationalProblem(F, u, bcs, J) solver = NonlinearVariationalSolver(problem) prm = solver.parameters prm['newton_solver']['absolute_tolerance'] = 1E-5 prm['newton_solver']['relative_tolerance'] = 1E-5 prm['newton_solver']['maximum_iterations'] = 25 solver.solve() (4, True) plot(u) [<matplotlib.lines.Line2D at 0x7f38ee302940>]","title":"Automatic Differentiation"},{"location":"2_notebooks/day-2/tutorials/1_non_linear_poisson_picard/","text":"Nonlinear Poisson equation \\[-div(q(u)*\\Delta(u)) = 0,$$ $$u = 0\\text{ at }x=0, u=1\\text{ at }x=1$$ $$q(u) = (1+u)^m\\] Solution method: Picard iteration (successive substitutions). Picard iteration is a simple and widely used technique for solving nonlinear equations. It is based on the idea of reformulating the original equation as a fixed-point problem. The method involves iteratively updating the solution until it converges to the desired solution. from dolfin import * import numpy mesh = IntervalMesh(40, 0, 1) V = FunctionSpace(mesh, 'Lagrange', 1) # Define boundary conditions tol = 1E-14 left_boundary = CompiledSubDomain(\"on_boundary && near(x[0],0)\") right_boundary = CompiledSubDomain(\"on_boundary && near(x[0],1)\") bc_0 = DirichletBC(V, Constant(0.0), left_boundary) bc_1 = DirichletBC(V, Constant(1.0), right_boundary) bcs = [bc_0, bc_1] m = 5 def q(u): return (1+u)**m # Define variational problem for Picard iteration u = TrialFunction(V) v = TestFunction(V) u_k = interpolate(Constant(0.0), V) # previous (known) u a = inner(q(u_k)*nabla_grad(u), nabla_grad(v))*dx f = Constant(0.0) L = f*v*dx Absolute tolerance and relative tolerance are two different concepts used to define the acceptable level of error or difference between two values when comparing them, especially in numerical computations, algorithms, and simulations. Absolute Tolerance: Absolute tolerance is a fixed value that represents the maximum allowable difference between two values. It is independent of the magnitude or scale of the values being compared. If the absolute difference between the two values is smaller than the absolute tolerance, they are considered to be equal or within the acceptable range. Relative Tolerance: Relative tolerance, on the other hand, takes into account the magnitude or scale of the values being compared. It defines an acceptable percentage or fraction of relative difference between two values. The idea is that the relative tolerance allows for more significant differences between large values and smaller differences between small values. This is especially useful when dealing with numbers of varying magnitudes. In summary, absolute tolerance is a fixed value used to check the maximum allowable difference, while relative tolerance is a percentage or fraction-based value that scales with the magnitude of the numbers being compared. Depending on the situation and the nature of the values being compared, one or both types of tolerances may be used to ensure accurate and meaningful comparisons. # Picard iterations u = Function(V) # new unknown function absolute_error = 1.0 # error measure ||u-u_k|| relative_error = 1.0 absolute_tolerance = 1.0E-5 # tolerance relative_tolerance = 1.0E-5 iter = 0 # iteration counter maxiter = 25 # max no of iterations allowed while (absolute_error > absolute_tolerance or relative_error > relative_tolerance) and iter < maxiter: iter += 1 solve(a == L, u, bcs) diff = u.vector().vec().array - u_k.vector().vec().array absolute_error = numpy.linalg.norm(diff) if iter > 1: relative_error = absolute_error / \\ min(numpy.linalg.norm(u.vector()[:]), numpy.linalg.norm(u_k.vector()[:])) print('iter ={0:3d}, absolute_error = {1:5.2e}, relative_error = {2:5.2e}'.format( iter, absolute_error, relative_error)) u_k.assign(u) # update for next iteration iter = 1, absolute_error = 3.72e+00, relative_error = 1.00e+00 iter = 2, absolute_error = 1.79e+00, relative_error = 4.80e-01 iter = 3, absolute_error = 3.56e-01, relative_error = 7.04e-02 iter = 4, absolute_error = 3.64e-01, relative_error = 7.60e-02 iter = 5, absolute_error = 9.05e-02, relative_error = 1.89e-02 iter = 6, absolute_error = 9.63e-02, relative_error = 1.99e-02 iter = 7, absolute_error = 2.93e-02, relative_error = 6.01e-03 iter = 8, absolute_error = 2.47e-02, relative_error = 5.07e-03 iter = 9, absolute_error = 1.00e-02, relative_error = 2.06e-03 iter = 10, absolute_error = 5.94e-03, relative_error = 1.22e-03 iter = 11, absolute_error = 3.27e-03, relative_error = 6.73e-04 iter = 12, absolute_error = 1.36e-03, relative_error = 2.80e-04 iter = 13, absolute_error = 1.01e-03, relative_error = 2.08e-04 iter = 14, absolute_error = 3.06e-04, relative_error = 6.28e-05 iter = 15, absolute_error = 2.97e-04, relative_error = 6.09e-05 iter = 16, absolute_error = 7.57e-05, relative_error = 1.56e-05 iter = 17, absolute_error = 8.20e-05, relative_error = 1.68e-05 iter = 18, absolute_error = 2.31e-05, relative_error = 4.75e-06 iter = 19, absolute_error = 2.14e-05, relative_error = 4.40e-06 iter = 20, absolute_error = 7.85e-06, relative_error = 1.61e-06 plot(u_k) [<matplotlib.lines.Line2D at 0x7f38ed58e710>] # Find max error u_exact = Expression( 'pow((pow(2, m+1)-1)*x[0] + 1, 1.0/(m+1)) - 1', m=m, degree=1) u_e = interpolate(u_exact, V) diff = numpy.abs(u_e.vector()[:] - u.vector()[:]).max() print('Max error:{0:5.3e}'.format(diff)) Max error:1.208e-06","title":"1_non_linear_poisson_picard.md"},{"location":"2_notebooks/day-2/tutorials/1_non_linear_poisson_picard/#nonlinear-poisson-equation","text":"\\[-div(q(u)*\\Delta(u)) = 0,$$ $$u = 0\\text{ at }x=0, u=1\\text{ at }x=1$$ $$q(u) = (1+u)^m\\] Solution method: Picard iteration (successive substitutions). Picard iteration is a simple and widely used technique for solving nonlinear equations. It is based on the idea of reformulating the original equation as a fixed-point problem. The method involves iteratively updating the solution until it converges to the desired solution. from dolfin import * import numpy mesh = IntervalMesh(40, 0, 1) V = FunctionSpace(mesh, 'Lagrange', 1) # Define boundary conditions tol = 1E-14 left_boundary = CompiledSubDomain(\"on_boundary && near(x[0],0)\") right_boundary = CompiledSubDomain(\"on_boundary && near(x[0],1)\") bc_0 = DirichletBC(V, Constant(0.0), left_boundary) bc_1 = DirichletBC(V, Constant(1.0), right_boundary) bcs = [bc_0, bc_1] m = 5 def q(u): return (1+u)**m # Define variational problem for Picard iteration u = TrialFunction(V) v = TestFunction(V) u_k = interpolate(Constant(0.0), V) # previous (known) u a = inner(q(u_k)*nabla_grad(u), nabla_grad(v))*dx f = Constant(0.0) L = f*v*dx Absolute tolerance and relative tolerance are two different concepts used to define the acceptable level of error or difference between two values when comparing them, especially in numerical computations, algorithms, and simulations. Absolute Tolerance: Absolute tolerance is a fixed value that represents the maximum allowable difference between two values. It is independent of the magnitude or scale of the values being compared. If the absolute difference between the two values is smaller than the absolute tolerance, they are considered to be equal or within the acceptable range. Relative Tolerance: Relative tolerance, on the other hand, takes into account the magnitude or scale of the values being compared. It defines an acceptable percentage or fraction of relative difference between two values. The idea is that the relative tolerance allows for more significant differences between large values and smaller differences between small values. This is especially useful when dealing with numbers of varying magnitudes. In summary, absolute tolerance is a fixed value used to check the maximum allowable difference, while relative tolerance is a percentage or fraction-based value that scales with the magnitude of the numbers being compared. Depending on the situation and the nature of the values being compared, one or both types of tolerances may be used to ensure accurate and meaningful comparisons. # Picard iterations u = Function(V) # new unknown function absolute_error = 1.0 # error measure ||u-u_k|| relative_error = 1.0 absolute_tolerance = 1.0E-5 # tolerance relative_tolerance = 1.0E-5 iter = 0 # iteration counter maxiter = 25 # max no of iterations allowed while (absolute_error > absolute_tolerance or relative_error > relative_tolerance) and iter < maxiter: iter += 1 solve(a == L, u, bcs) diff = u.vector().vec().array - u_k.vector().vec().array absolute_error = numpy.linalg.norm(diff) if iter > 1: relative_error = absolute_error / \\ min(numpy.linalg.norm(u.vector()[:]), numpy.linalg.norm(u_k.vector()[:])) print('iter ={0:3d}, absolute_error = {1:5.2e}, relative_error = {2:5.2e}'.format( iter, absolute_error, relative_error)) u_k.assign(u) # update for next iteration iter = 1, absolute_error = 3.72e+00, relative_error = 1.00e+00 iter = 2, absolute_error = 1.79e+00, relative_error = 4.80e-01 iter = 3, absolute_error = 3.56e-01, relative_error = 7.04e-02 iter = 4, absolute_error = 3.64e-01, relative_error = 7.60e-02 iter = 5, absolute_error = 9.05e-02, relative_error = 1.89e-02 iter = 6, absolute_error = 9.63e-02, relative_error = 1.99e-02 iter = 7, absolute_error = 2.93e-02, relative_error = 6.01e-03 iter = 8, absolute_error = 2.47e-02, relative_error = 5.07e-03 iter = 9, absolute_error = 1.00e-02, relative_error = 2.06e-03 iter = 10, absolute_error = 5.94e-03, relative_error = 1.22e-03 iter = 11, absolute_error = 3.27e-03, relative_error = 6.73e-04 iter = 12, absolute_error = 1.36e-03, relative_error = 2.80e-04 iter = 13, absolute_error = 1.01e-03, relative_error = 2.08e-04 iter = 14, absolute_error = 3.06e-04, relative_error = 6.28e-05 iter = 15, absolute_error = 2.97e-04, relative_error = 6.09e-05 iter = 16, absolute_error = 7.57e-05, relative_error = 1.56e-05 iter = 17, absolute_error = 8.20e-05, relative_error = 1.68e-05 iter = 18, absolute_error = 2.31e-05, relative_error = 4.75e-06 iter = 19, absolute_error = 2.14e-05, relative_error = 4.40e-06 iter = 20, absolute_error = 7.85e-06, relative_error = 1.61e-06 plot(u_k) [<matplotlib.lines.Line2D at 0x7f38ed58e710>] # Find max error u_exact = Expression( 'pow((pow(2, m+1)-1)*x[0] + 1, 1.0/(m+1)) - 1', m=m, degree=1) u_e = interpolate(u_exact, V) diff = numpy.abs(u_e.vector()[:] - u.vector()[:]).max() print('Max error:{0:5.3e}'.format(diff)) Max error:1.208e-06","title":"Nonlinear Poisson equation"},{"location":"2_notebooks/day-2/tutorials/2_non_linear_poisson_newton/","text":"Nonlinear Poisson equation \\[-div(q(u)*\\Delta(u)) = 0,$$ $$u = 0\\text{ at }x=0, u=1\\text{ at }x=1$$ $$q(u) = (1+u)^m\\] Solution method: Newton method Newton iteration is a more sophisticated method for solving nonlinear equations and systems. It is based on linearizing the original problem around an initial guess and then iteratively improving the solution by solving linear approximations of the problem. The Newton method is known for its quadratic convergence, which means that the number of correct digits in the solution roughly doubles with each iteration, making it faster than Picard iteration for problems where it converges. import matplotlib.pyplot as plt import numpy as np def newton_method(func, derivative, x0, tolerance=1e-6, max_iterations=2): x_vals = [x0] iteration = 0 while iteration < max_iterations: x_next = x_vals[-1] - func(x_vals[-1]) / derivative(x_vals[-1]) x_vals.append(x_next) if abs(x_vals[-1] - x_vals[-2]) < tolerance: break iteration += 1 return x_vals # Define the function and its derivative def func(x): return x**3 - 3*x**2 + 2 def derivative(x): tangent_modifier = 2.7 return tangent_modifier*(3*x**2 - 6*x) # Initial guess for the root and perform Newton's method initial_guess = 4 root_approximations = newton_method(func, derivative, initial_guess) # Visualization x_vals = np.linspace(1, 4, 100) y_vals = func(x_vals) plt.figure(figsize=(8, 6)) plt.plot(x_vals, y_vals, label='Function: $x^3 - 3x^2 + 2$') plt.scatter(root_approximations, [func(root) for root in root_approximations], c='red', label='Root Approximations') for i, root in enumerate(root_approximations): # plt.annotate(f'Root {i+1}', xy=(root, func(root)), xytext=(root+0.4, func(root) + 4), arrowprops=dict(arrowstyle='->', lw=1.5)) # Plotting tangent lines tangent_x = np.linspace(root - 2, root + 2, 100) tangent_y = func(root) + derivative(root) * (tangent_x - root) plt.plot(tangent_x, tangent_y, linestyle='dashed', color='gray') plt.axhline(0, color='black', linewidth=0.5) plt.axvline(0, color='black', linewidth=0.5) plt.xlabel('x') plt.ylabel('y') plt.legend() # Set xlim and ylim based on the root approximations plt.xlim(2, 4.3) plt.ylim(min(y_vals) - 1, max(y_vals) + 1) plt.title(\"Newton's Method Visualization with Tangents\") plt.grid(True) plt.show() from dolfin import * import numpy %matplotlib inline mesh = IntervalMesh(40,0,1) V = FunctionSpace(mesh, 'Lagrange', 1) # Define boundary conditions tol = 1E-14 left_boundary = CompiledSubDomain(\"on_boundary && near(x[0],0)\") right_boundary = CompiledSubDomain(\"on_boundary && near(x[0],1)\") bc_0 = DirichletBC(V, Constant(0.0), left_boundary) bc_1 = DirichletBC(V, Constant(1.0), right_boundary) bcs = [bc_0, bc_1] m = 5 def q(u): return (1+u)**m def Dq(u): return m*(1+u)**(m-1) Go to this link for derivation https://home.simula.no/~hpl/homepage/fenics-tutorial/release-1.0/webm/nonlinear.html#a-newton-method-at-the-pde-level # Define variational problem for initial guess (q(u)=1, i.e., m=0) u = TrialFunction(V) v = TestFunction(V) a = inner(nabla_grad(u), nabla_grad(v))*dx f = Constant(0.0) L = f*v*dx u_k = Function(V) solve(a == L, u_k, bcs) # Note that all Dirichlet conditions must be zero for # the correction function in a Newton-type method Gamma_0_du = DirichletBC(V, Constant(0.0), left_boundary) Gamma_1_du = DirichletBC(V, Constant(0.0), right_boundary) bcs_du = [Gamma_0_du, Gamma_1_du] # Define variational problem for Newton iteration du = TrialFunction(V) # u = u_k + omega*du a = inner(q(u_k)*nabla_grad(du), nabla_grad(v))*dx + \\ inner(Dq(u_k)*du*nabla_grad(u_k), nabla_grad(v))*dx L = -inner(q(u_k)*nabla_grad(u_k), nabla_grad(v))*dx # Newton iteration at the PDE level du = Function(V) u = Function(V) # u = u_k + omega*du omega = 1.0 # relaxation parameter absolute_error = 1.0 relative_error = 1.0 absolute_tolerance = 1.0E-5 # tolerance relative_tolerance = 1.0E-5 iter = 0 maxiter = 25 # u_k must have right boundary conditions here while (absolute_error > absolute_tolerance or relative_error > relative_tolerance) and iter < maxiter: iter += 1 A, b = assemble_system(a, L, bcs_du) solve(A, du.vector(), b) diff = du.vector()[:] absolute_error = numpy.linalg.norm(diff) relative_error = absolute_error/numpy.linalg.norm(u_k.vector()[:]) u.vector()[:] = u_k.vector() + omega*du.vector() print('iter ={0:3d}, absolute_error = {1:5.2e}, relative_error = {2:5.2e}'.format( iter, absolute_error, relative_error)) u_k.assign(u) iter = 1, absolute_error = 2.87e+00, relative_error = 7.71e-01 iter = 2, absolute_error = 9.00e-01, relative_error = 1.55e-01 iter = 3, absolute_error = 3.63e-01, relative_error = 7.10e-02 iter = 4, absolute_error = 6.46e-02, relative_error = 1.32e-02 iter = 5, absolute_error = 2.21e-03, relative_error = 4.53e-04 iter = 6, absolute_error = 2.98e-06, relative_error = 6.12e-07 plot(u) [<matplotlib.lines.Line2D at 0x7f38e89d5198>] # Find max error u_exact = Expression( 'pow((pow(2, m+1)-1)*x[0] + 1, 1.0/(m+1)) - 1', m=m, degree=1) u_e = interpolate(u_exact, V) diff = numpy.abs(u_e.vector()[:] - u.vector()[:]).max() print('Max error:{0:5.3e}'.format(diff)) Max error:4.014e-12","title":"2_non_linear_poisson_newton.md"},{"location":"2_notebooks/day-2/tutorials/2_non_linear_poisson_newton/#nonlinear-poisson-equation","text":"\\[-div(q(u)*\\Delta(u)) = 0,$$ $$u = 0\\text{ at }x=0, u=1\\text{ at }x=1$$ $$q(u) = (1+u)^m\\] Solution method: Newton method Newton iteration is a more sophisticated method for solving nonlinear equations and systems. It is based on linearizing the original problem around an initial guess and then iteratively improving the solution by solving linear approximations of the problem. The Newton method is known for its quadratic convergence, which means that the number of correct digits in the solution roughly doubles with each iteration, making it faster than Picard iteration for problems where it converges. import matplotlib.pyplot as plt import numpy as np def newton_method(func, derivative, x0, tolerance=1e-6, max_iterations=2): x_vals = [x0] iteration = 0 while iteration < max_iterations: x_next = x_vals[-1] - func(x_vals[-1]) / derivative(x_vals[-1]) x_vals.append(x_next) if abs(x_vals[-1] - x_vals[-2]) < tolerance: break iteration += 1 return x_vals # Define the function and its derivative def func(x): return x**3 - 3*x**2 + 2 def derivative(x): tangent_modifier = 2.7 return tangent_modifier*(3*x**2 - 6*x) # Initial guess for the root and perform Newton's method initial_guess = 4 root_approximations = newton_method(func, derivative, initial_guess) # Visualization x_vals = np.linspace(1, 4, 100) y_vals = func(x_vals) plt.figure(figsize=(8, 6)) plt.plot(x_vals, y_vals, label='Function: $x^3 - 3x^2 + 2$') plt.scatter(root_approximations, [func(root) for root in root_approximations], c='red', label='Root Approximations') for i, root in enumerate(root_approximations): # plt.annotate(f'Root {i+1}', xy=(root, func(root)), xytext=(root+0.4, func(root) + 4), arrowprops=dict(arrowstyle='->', lw=1.5)) # Plotting tangent lines tangent_x = np.linspace(root - 2, root + 2, 100) tangent_y = func(root) + derivative(root) * (tangent_x - root) plt.plot(tangent_x, tangent_y, linestyle='dashed', color='gray') plt.axhline(0, color='black', linewidth=0.5) plt.axvline(0, color='black', linewidth=0.5) plt.xlabel('x') plt.ylabel('y') plt.legend() # Set xlim and ylim based on the root approximations plt.xlim(2, 4.3) plt.ylim(min(y_vals) - 1, max(y_vals) + 1) plt.title(\"Newton's Method Visualization with Tangents\") plt.grid(True) plt.show() from dolfin import * import numpy %matplotlib inline mesh = IntervalMesh(40,0,1) V = FunctionSpace(mesh, 'Lagrange', 1) # Define boundary conditions tol = 1E-14 left_boundary = CompiledSubDomain(\"on_boundary && near(x[0],0)\") right_boundary = CompiledSubDomain(\"on_boundary && near(x[0],1)\") bc_0 = DirichletBC(V, Constant(0.0), left_boundary) bc_1 = DirichletBC(V, Constant(1.0), right_boundary) bcs = [bc_0, bc_1] m = 5 def q(u): return (1+u)**m def Dq(u): return m*(1+u)**(m-1) Go to this link for derivation https://home.simula.no/~hpl/homepage/fenics-tutorial/release-1.0/webm/nonlinear.html#a-newton-method-at-the-pde-level # Define variational problem for initial guess (q(u)=1, i.e., m=0) u = TrialFunction(V) v = TestFunction(V) a = inner(nabla_grad(u), nabla_grad(v))*dx f = Constant(0.0) L = f*v*dx u_k = Function(V) solve(a == L, u_k, bcs) # Note that all Dirichlet conditions must be zero for # the correction function in a Newton-type method Gamma_0_du = DirichletBC(V, Constant(0.0), left_boundary) Gamma_1_du = DirichletBC(V, Constant(0.0), right_boundary) bcs_du = [Gamma_0_du, Gamma_1_du] # Define variational problem for Newton iteration du = TrialFunction(V) # u = u_k + omega*du a = inner(q(u_k)*nabla_grad(du), nabla_grad(v))*dx + \\ inner(Dq(u_k)*du*nabla_grad(u_k), nabla_grad(v))*dx L = -inner(q(u_k)*nabla_grad(u_k), nabla_grad(v))*dx # Newton iteration at the PDE level du = Function(V) u = Function(V) # u = u_k + omega*du omega = 1.0 # relaxation parameter absolute_error = 1.0 relative_error = 1.0 absolute_tolerance = 1.0E-5 # tolerance relative_tolerance = 1.0E-5 iter = 0 maxiter = 25 # u_k must have right boundary conditions here while (absolute_error > absolute_tolerance or relative_error > relative_tolerance) and iter < maxiter: iter += 1 A, b = assemble_system(a, L, bcs_du) solve(A, du.vector(), b) diff = du.vector()[:] absolute_error = numpy.linalg.norm(diff) relative_error = absolute_error/numpy.linalg.norm(u_k.vector()[:]) u.vector()[:] = u_k.vector() + omega*du.vector() print('iter ={0:3d}, absolute_error = {1:5.2e}, relative_error = {2:5.2e}'.format( iter, absolute_error, relative_error)) u_k.assign(u) iter = 1, absolute_error = 2.87e+00, relative_error = 7.71e-01 iter = 2, absolute_error = 9.00e-01, relative_error = 1.55e-01 iter = 3, absolute_error = 3.63e-01, relative_error = 7.10e-02 iter = 4, absolute_error = 6.46e-02, relative_error = 1.32e-02 iter = 5, absolute_error = 2.21e-03, relative_error = 4.53e-04 iter = 6, absolute_error = 2.98e-06, relative_error = 6.12e-07 plot(u) [<matplotlib.lines.Line2D at 0x7f38e89d5198>] # Find max error u_exact = Expression( 'pow((pow(2, m+1)-1)*x[0] + 1, 1.0/(m+1)) - 1', m=m, degree=1) u_e = interpolate(u_exact, V) diff = numpy.abs(u_e.vector()[:] - u.vector()[:]).max() print('Max error:{0:5.3e}'.format(diff)) Max error:4.014e-12","title":"Nonlinear Poisson equation"},{"location":"2_notebooks/day-2/tutorials/3_non_linear_poisson_newton_manual_diff/","text":"Nonlinear Poisson equation \\[-div(q(u)*\\Delta(u)) = 0,$$ $$u = 0\\text{ at }x=0, u=1\\text{ at }x=1$$ $$q(u) = (1+u)^m\\] Solution method: Newton method Newton iteration is a more sophisticated method for solving nonlinear equations and systems. It is based on linearizing the original problem around an initial guess and then iteratively improving the solution by solving linear approximations of the problem. The Newton iteration can be written in the form: \\[x_{n+1} = x_n - J^{-1}(x_n) * F(x_n)\\] where \\(x_{n+1}\\) is the updated solution at the (n+1)th iteration, \\(x_n\\) is the solution at the nth iteration, \\(J^{-1}(x_n)\\) is the inverse Jacobian matrix of the problem evaluated at \\(x_n\\) , and \\(F(x_n)\\) is the residual vector of the problem evaluated at \\(x_n\\) . The Newton method is known for its quadratic convergence, which means that the number of correct digits in the solution roughly doubles with each iteration, making it faster than Picard iteration for problems where it converges. However, Newton's method may not converge if the initial guess is far from the true solution, or if the Jacobian matrix is ill-conditioned or singular at the current solution. from dolfin import * import numpy %matplotlib inline mesh = IntervalMesh(40,0,1) V = FunctionSpace(mesh, 'Lagrange', 1) # Define boundary conditions tol = 1E-14 left_boundary = CompiledSubDomain(\"on_boundary && near(x[0],0)\") right_boundary = CompiledSubDomain(\"on_boundary && near(x[0],1)\") bc_0 = DirichletBC(V, Constant(0.0), left_boundary) bc_1 = DirichletBC(V, Constant(1.0), right_boundary) bcs = [bc_0, bc_1] m = 5 def q(u): return (1+u)**m def Dq(u): return m*(1+u)**(m-1) Newtons method require the evaluation of Jacobian. In this notebook we use manual differentiation for the evaluation of Jacobian. Manual differentiation involves calculating derivatives by hand, which can be error-prone and time-consuming for complex functions. \\[F=q(u)\\nabla u \\cdot \\nabla v\\ \\mathrm{d}x$$ $$J = q(u)\\nabla \\delta u \\cdot \\nabla v\\ \\mathrm{d}x + q'(u)\\delta u\\nabla u \\cdot \\nabla v\\ \\mathrm{d}x\\] Go to this link for derivation https://home.simula.no/~hpl/homepage/fenics-tutorial/release-1.0/webm/nonlinear.html#a-newton-method-at-the-pde-level # Define variational problem v = TestFunction(V) du = TrialFunction(V) u = Function(V) # most recently computed solution F = inner(q(u)*nabla_grad(u), nabla_grad(v))*dx J = inner(q(u)*nabla_grad(du), nabla_grad(v))*dx + \\ inner(Dq(u)*du*nabla_grad(u), nabla_grad(v))*dx (6, True) # Compute solution problem = NonlinearVariationalProblem(F, u, bcs, J) solver = NonlinearVariationalSolver(problem) prm = solver.parameters prm['newton_solver']['absolute_tolerance'] = 1E-5 prm['newton_solver']['relative_tolerance'] = 1E-5 prm['newton_solver']['maximum_iterations'] = 25 solver.solve() plot(u) [<matplotlib.lines.Line2D at 0x7f38ed8d4b38>] # Find max error u_exact = Expression( 'pow((pow(2, m+1)-1)*x[0] + 1, 1.0/(m+1)) - 1', m=m, degree=1) u_e = interpolate(u_exact, V) diff = numpy.abs(u_e.vector()[:] - u.vector()[:]).max() print('Max error:{0:5.3e}'.format(diff)) Max error:1.559e-06","title":"3_non_linear_poisson_newton_manual_diff.md"},{"location":"2_notebooks/day-2/tutorials/3_non_linear_poisson_newton_manual_diff/#nonlinear-poisson-equation","text":"\\[-div(q(u)*\\Delta(u)) = 0,$$ $$u = 0\\text{ at }x=0, u=1\\text{ at }x=1$$ $$q(u) = (1+u)^m\\] Solution method: Newton method Newton iteration is a more sophisticated method for solving nonlinear equations and systems. It is based on linearizing the original problem around an initial guess and then iteratively improving the solution by solving linear approximations of the problem. The Newton iteration can be written in the form: \\[x_{n+1} = x_n - J^{-1}(x_n) * F(x_n)\\] where \\(x_{n+1}\\) is the updated solution at the (n+1)th iteration, \\(x_n\\) is the solution at the nth iteration, \\(J^{-1}(x_n)\\) is the inverse Jacobian matrix of the problem evaluated at \\(x_n\\) , and \\(F(x_n)\\) is the residual vector of the problem evaluated at \\(x_n\\) . The Newton method is known for its quadratic convergence, which means that the number of correct digits in the solution roughly doubles with each iteration, making it faster than Picard iteration for problems where it converges. However, Newton's method may not converge if the initial guess is far from the true solution, or if the Jacobian matrix is ill-conditioned or singular at the current solution. from dolfin import * import numpy %matplotlib inline mesh = IntervalMesh(40,0,1) V = FunctionSpace(mesh, 'Lagrange', 1) # Define boundary conditions tol = 1E-14 left_boundary = CompiledSubDomain(\"on_boundary && near(x[0],0)\") right_boundary = CompiledSubDomain(\"on_boundary && near(x[0],1)\") bc_0 = DirichletBC(V, Constant(0.0), left_boundary) bc_1 = DirichletBC(V, Constant(1.0), right_boundary) bcs = [bc_0, bc_1] m = 5 def q(u): return (1+u)**m def Dq(u): return m*(1+u)**(m-1) Newtons method require the evaluation of Jacobian. In this notebook we use manual differentiation for the evaluation of Jacobian. Manual differentiation involves calculating derivatives by hand, which can be error-prone and time-consuming for complex functions. \\[F=q(u)\\nabla u \\cdot \\nabla v\\ \\mathrm{d}x$$ $$J = q(u)\\nabla \\delta u \\cdot \\nabla v\\ \\mathrm{d}x + q'(u)\\delta u\\nabla u \\cdot \\nabla v\\ \\mathrm{d}x\\] Go to this link for derivation https://home.simula.no/~hpl/homepage/fenics-tutorial/release-1.0/webm/nonlinear.html#a-newton-method-at-the-pde-level # Define variational problem v = TestFunction(V) du = TrialFunction(V) u = Function(V) # most recently computed solution F = inner(q(u)*nabla_grad(u), nabla_grad(v))*dx J = inner(q(u)*nabla_grad(du), nabla_grad(v))*dx + \\ inner(Dq(u)*du*nabla_grad(u), nabla_grad(v))*dx (6, True) # Compute solution problem = NonlinearVariationalProblem(F, u, bcs, J) solver = NonlinearVariationalSolver(problem) prm = solver.parameters prm['newton_solver']['absolute_tolerance'] = 1E-5 prm['newton_solver']['relative_tolerance'] = 1E-5 prm['newton_solver']['maximum_iterations'] = 25 solver.solve() plot(u) [<matplotlib.lines.Line2D at 0x7f38ed8d4b38>] # Find max error u_exact = Expression( 'pow((pow(2, m+1)-1)*x[0] + 1, 1.0/(m+1)) - 1', m=m, degree=1) u_e = interpolate(u_exact, V) diff = numpy.abs(u_e.vector()[:] - u.vector()[:]).max() print('Max error:{0:5.3e}'.format(diff)) Max error:1.559e-06","title":"Nonlinear Poisson equation"},{"location":"2_notebooks/day-2/tutorials/4_non_linear_poisson_newton_auto_diff/","text":"Nonlinear Poisson equation \\[-div(q(u)*\\Delta(u)) = 0,$$ $$u = 0\\text{ at }x=0, u=1\\text{ at }x=1$$ $$q(u) = (1+u)^m\\] Solution method: Newton iteration (Automatic Differentation). As opposed to manual differentiation, automatic differentiation is a more efficient and accurate way to compute derivatives of functions numerically, making it a popular choice in modern machine learning and optimization applications. from dolfin import * import numpy % matplotlib inline mesh = IntervalMesh ( 40 , 0 , 1 ) V = FunctionSpace ( mesh , 'Lagrange' , 1 ) # Define boundary conditions tol = 1E-14 left_boundary = CompiledSubDomain ( \"on_boundary && near(x[0],0)\" ) right_boundary = CompiledSubDomain ( \"on_boundary && near(x[0],1)\" ) bc_0 = DirichletBC ( V , Constant ( 0.0 ), left_boundary ) bc_1 = DirichletBC ( V , Constant ( 1.0 ), right_boundary ) bcs = [ bc_0 , bc_1 ] m = 5 def q ( u ): return ( 1 + u ) ** m # Define variational problem v = TestFunction ( V ) du = TrialFunction ( V ) u = Function ( V ) # most recently computed solution F = inner ( q ( u ) * nabla_grad ( u ), nabla_grad ( v )) * dx FEniCS provides a high-level interface for expressing and solving PDEs and has built-in capabilities for automatic differentiation (AD). In FEniCS, AD is used to efficiently compute the derivatives of the weak forms of PDEs with respect to the unknowns (e.g., displacement, velocity, pressure, etc.) in the problem. This allows for the automatic construction of the Jacobian matrix and the right-hand side (RHS) vector, which are essential for solving the nonlinear systems arising from finite element discretizations. By leveraging AD, FEniCS can handle complex PDE problems with ease, as it relieves the user from having to derive and implement the derivatives manually, which can be a tedious and error-prone process, especially for intricate problems. J = derivative ( F , u , du ) # Compute solution problem = NonlinearVariationalProblem ( F , u , bcs , J ) solver = NonlinearVariationalSolver ( problem ) prm = solver . parameters prm [ 'newton_solver' ][ 'absolute_tolerance' ] = 1E-5 prm [ 'newton_solver' ][ 'relative_tolerance' ] = 1E-5 prm [ 'newton_solver' ][ 'maximum_iterations' ] = 25 solver . solve () (6, True) plot ( u ) [<matplotlib.lines.Line2D at 0x7f38ed0a2358>] # Find max error u_exact = Expression ( 'pow((pow(2, m+1)-1)*x[0] + 1, 1.0/(m+1)) - 1' , m = m , degree = 1 ) u_e = interpolate ( u_exact , V ) diff = numpy . abs ( u_e . vector ()[:] - u . vector ()[:]) . max () print ( 'Max error: {0:5.3e} ' . format ( diff )) Max error:1.559e-06","title":"4_non_linear_poisson_newton_auto_diff.md"},{"location":"2_notebooks/day-2/tutorials/4_non_linear_poisson_newton_auto_diff/#nonlinear-poisson-equation","text":"\\[-div(q(u)*\\Delta(u)) = 0,$$ $$u = 0\\text{ at }x=0, u=1\\text{ at }x=1$$ $$q(u) = (1+u)^m\\] Solution method: Newton iteration (Automatic Differentation). As opposed to manual differentiation, automatic differentiation is a more efficient and accurate way to compute derivatives of functions numerically, making it a popular choice in modern machine learning and optimization applications. from dolfin import * import numpy % matplotlib inline mesh = IntervalMesh ( 40 , 0 , 1 ) V = FunctionSpace ( mesh , 'Lagrange' , 1 ) # Define boundary conditions tol = 1E-14 left_boundary = CompiledSubDomain ( \"on_boundary && near(x[0],0)\" ) right_boundary = CompiledSubDomain ( \"on_boundary && near(x[0],1)\" ) bc_0 = DirichletBC ( V , Constant ( 0.0 ), left_boundary ) bc_1 = DirichletBC ( V , Constant ( 1.0 ), right_boundary ) bcs = [ bc_0 , bc_1 ] m = 5 def q ( u ): return ( 1 + u ) ** m # Define variational problem v = TestFunction ( V ) du = TrialFunction ( V ) u = Function ( V ) # most recently computed solution F = inner ( q ( u ) * nabla_grad ( u ), nabla_grad ( v )) * dx FEniCS provides a high-level interface for expressing and solving PDEs and has built-in capabilities for automatic differentiation (AD). In FEniCS, AD is used to efficiently compute the derivatives of the weak forms of PDEs with respect to the unknowns (e.g., displacement, velocity, pressure, etc.) in the problem. This allows for the automatic construction of the Jacobian matrix and the right-hand side (RHS) vector, which are essential for solving the nonlinear systems arising from finite element discretizations. By leveraging AD, FEniCS can handle complex PDE problems with ease, as it relieves the user from having to derive and implement the derivatives manually, which can be a tedious and error-prone process, especially for intricate problems. J = derivative ( F , u , du ) # Compute solution problem = NonlinearVariationalProblem ( F , u , bcs , J ) solver = NonlinearVariationalSolver ( problem ) prm = solver . parameters prm [ 'newton_solver' ][ 'absolute_tolerance' ] = 1E-5 prm [ 'newton_solver' ][ 'relative_tolerance' ] = 1E-5 prm [ 'newton_solver' ][ 'maximum_iterations' ] = 25 solver . solve () (6, True) plot ( u ) [<matplotlib.lines.Line2D at 0x7f38ed0a2358>] # Find max error u_exact = Expression ( 'pow((pow(2, m+1)-1)*x[0] + 1, 1.0/(m+1)) - 1' , m = m , degree = 1 ) u_e = interpolate ( u_exact , V ) diff = numpy . abs ( u_e . vector ()[:] - u . vector ()[:]) . max () print ( 'Max error: {0:5.3e} ' . format ( diff )) Max error:1.559e-06","title":"Nonlinear Poisson equation"},{"location":"2_notebooks/day-3/exercises/1_3d_uniaxial/","text":"3D Uniaxial bar The objective of this exercise is to implement a 3D finite element analysis (FEA) program using FEniCS. You are required to create a FEniCS code that performs the analysis, solve for the displacements and stresses in the bar, and visualize the results. Materials: - Steel material properties: - Young's Modulus (E): 200 GPa - Poisson's Ratio (\u03bd): 0.3 - Density (\u03c1): 7850 kg/m^3 Bar Dimensions: - Length (Lx): 1 meter - Ly and Lz: 0.02 meters (20 mm) Boundary Conditions: - One end of the bar is fixed (fixed boundary condition). - The other end is subjected to a uniaxial tensile load: - Load (F): 10,000 N Mesh: - Use a simple 3D mesh for the bar, consisting of tetrahedral elements. Steps: Import FEniCS and Necessary Libraries Define the Geometry and Mesh Define the Material Properties Define the Boundary Conditions Define the Finite Element Function Space Formulate the Governing Equations. Solve the System Calculate Stress Post-Processing and Visualization: from dolfin import * mesh = BoxMesh ( Point ( 0 , 0 , 0 ), Point ( 1 , 1 , 1 ), 3 , 3 , 3 ) mesh FEniCS/DOLFIN X3DOM plot Options Summary Color Warp Viewpoints Menu Options Summary Color Warp Viewpoints Number of vertices: 64 Number of cells: 162 Show Color Current Color Map: Warp By Scalar 1 Viewpoint Options front back left right top bottom","title":"1_3d_uniaxial.md"},{"location":"2_notebooks/day-3/exercises/1_3d_uniaxial/#3d-uniaxial-bar","text":"The objective of this exercise is to implement a 3D finite element analysis (FEA) program using FEniCS. You are required to create a FEniCS code that performs the analysis, solve for the displacements and stresses in the bar, and visualize the results. Materials: - Steel material properties: - Young's Modulus (E): 200 GPa - Poisson's Ratio (\u03bd): 0.3 - Density (\u03c1): 7850 kg/m^3 Bar Dimensions: - Length (Lx): 1 meter - Ly and Lz: 0.02 meters (20 mm) Boundary Conditions: - One end of the bar is fixed (fixed boundary condition). - The other end is subjected to a uniaxial tensile load: - Load (F): 10,000 N Mesh: - Use a simple 3D mesh for the bar, consisting of tetrahedral elements. Steps: Import FEniCS and Necessary Libraries Define the Geometry and Mesh Define the Material Properties Define the Boundary Conditions Define the Finite Element Function Space Formulate the Governing Equations. Solve the System Calculate Stress Post-Processing and Visualization: from dolfin import * mesh = BoxMesh ( Point ( 0 , 0 , 0 ), Point ( 1 , 1 , 1 ), 3 , 3 , 3 ) mesh FEniCS/DOLFIN X3DOM plot Options Summary Color Warp Viewpoints Menu Options Summary Color Warp Viewpoints Number of vertices: 64 Number of cells: 162 Show Color Current Color Map: Warp By Scalar 1 Viewpoint Options front back left right top bottom","title":"3D Uniaxial bar"},{"location":"2_notebooks/day-3/exercises/2_plane_stress_strain/","text":"Plane stress v/s plane strain The objective of this exercise is to implement a finite element analysis (FEA) program using FEniCS to simulate the behavior of a beam under bending, considering both plane stress and plane strain conditions. You will write a FEniCS code to perform the analysis for both cases and compare the results with a 3D analysis of the same beam. 1m 0 . 45m 0 .3 m Materials: - Steel material properties: - Young's Modulus (E): 200 GPa - Poisson's Ratio (\u03bd): 0.3 - Density (\u03c1): 7850 kg/m^3 Bar Dimensions: - Length (Lx): 1 meter - Ly : 0.3 meter - Lz : 0.45 meter Boundary Conditions: - One end of the beam is fixed (fixed boundary condition). - The other end is subjected to a uniaxial downward load: - Load (F): 10,000 N Mesh: - For 3D analysis use a simple 3D mesh for the beam, consisting of tetrahedral elements. - For 2D analysis use a simple 2D mesh for the beam, consisting of triangular elements. Steps: - Perform 3D analysis 1. Import FEniCS and Necessary Libraries 2. Define the 3D Geometry and Mesh 3. Define the Material Properties 4. Define the Boundary Conditions 5. Define the Finite Element Function Space 6. Formulate the Governing Equations 7. Solve the System - Perform 2D plane stress analysis 1. Define the 2D Geometry and Mesh 2. Define the Material Properties 3. Define the Boundary Conditions 4. Define the Finite Element Function Space 5. Formulate the Governing Equations 6. Solve the System - Perform 2D plane strain analysis 1. Define the 2D Geometry and Mesh 2. Define the Material Properties 3. Define the Boundary Conditions 4. Define the Finite Element Function Space 5. Formulate the Governing Equations 6. Solve the System - Compare the results of plane stress, plane strain and 3D analysis with analytical solution. - See what happens to the solution when you increase the mesh density sim_types = [ \"3d\" , \"plane_stress\" , \"plane_strain\" ] sim_type = sim_types [ 0 ] E0 , nu = 2e11 , 0.3 mu = E0 / ( 2 * ( 1 + nu )) lmbda = E0 * nu / (( 1 + nu ) * ( 1 - 2 * nu )) if sim_type == \"plane_stress\" : lmbda = 2 * mu * lmbda / ( lmbda + 2 * mu )","title":"2_plane_stress_strain.md"},{"location":"2_notebooks/day-3/exercises/2_plane_stress_strain/#plane-stress-vs-plane-strain","text":"The objective of this exercise is to implement a finite element analysis (FEA) program using FEniCS to simulate the behavior of a beam under bending, considering both plane stress and plane strain conditions. You will write a FEniCS code to perform the analysis for both cases and compare the results with a 3D analysis of the same beam. 1m 0 . 45m 0 .3 m Materials: - Steel material properties: - Young's Modulus (E): 200 GPa - Poisson's Ratio (\u03bd): 0.3 - Density (\u03c1): 7850 kg/m^3 Bar Dimensions: - Length (Lx): 1 meter - Ly : 0.3 meter - Lz : 0.45 meter Boundary Conditions: - One end of the beam is fixed (fixed boundary condition). - The other end is subjected to a uniaxial downward load: - Load (F): 10,000 N Mesh: - For 3D analysis use a simple 3D mesh for the beam, consisting of tetrahedral elements. - For 2D analysis use a simple 2D mesh for the beam, consisting of triangular elements. Steps: - Perform 3D analysis 1. Import FEniCS and Necessary Libraries 2. Define the 3D Geometry and Mesh 3. Define the Material Properties 4. Define the Boundary Conditions 5. Define the Finite Element Function Space 6. Formulate the Governing Equations 7. Solve the System - Perform 2D plane stress analysis 1. Define the 2D Geometry and Mesh 2. Define the Material Properties 3. Define the Boundary Conditions 4. Define the Finite Element Function Space 5. Formulate the Governing Equations 6. Solve the System - Perform 2D plane strain analysis 1. Define the 2D Geometry and Mesh 2. Define the Material Properties 3. Define the Boundary Conditions 4. Define the Finite Element Function Space 5. Formulate the Governing Equations 6. Solve the System - Compare the results of plane stress, plane strain and 3D analysis with analytical solution. - See what happens to the solution when you increase the mesh density sim_types = [ \"3d\" , \"plane_stress\" , \"plane_strain\" ] sim_type = sim_types [ 0 ] E0 , nu = 2e11 , 0.3 mu = E0 / ( 2 * ( 1 + nu )) lmbda = E0 * nu / (( 1 + nu ) * ( 1 - 2 * nu )) if sim_type == \"plane_stress\" : lmbda = 2 * mu * lmbda / ( lmbda + 2 * mu )","title":"Plane stress v/s plane strain"},{"location":"2_notebooks/day-3/exercises/3_solver_design/","text":"Solver design The success of tackling complex problems often relies on the effectiveness of the solver employed. While formulating the mathematical model is crucial, paying attention to the design of an efficient and accurate solver is equally vital, as it directly impacts the quality and reliability of the results you obtain. In this exercise you will study the impact of different solver parameters on the solution. from dolfin import * def elasticity_problem ( num_ele_along_depth = 30 ): length , depth = 3 , .300 ele_size = depth / num_ele_along_depth mesh = RectangleMesh ( Point ( 0 , 0 ), Point ( length , depth ), int ( length / ele_size ), int ( depth / ele_size )) U = VectorFunctionSpace ( mesh , 'CG' , 1 ) dim = mesh . topology () . dim () clamped_boundary = CompiledSubDomain ( \"near(x[0],0)\" ) bc = DirichletBC ( U , Constant (( 0 ,) * dim ), clamped_boundary ) E , nu = 2e11 , 0.3 rho , g = 7800 , 9.81 lmbda = ( E * nu ) / (( 1 + nu ) * ( 1 - 2 * nu )) mu = E / ( 2 * ( 1 + nu )) def epsilon ( u ): return 0.5 * ( grad ( u ) + grad ( u ) . T ) def sigma ( u ): return lmbda * tr ( epsilon ( u )) * Identity ( dim ) + 2 * mu * epsilon ( u ) # Define variational problem u , v = TrialFunction ( U ), TestFunction ( U ) f = Constant (( 0 , - rho * g )) a = inner ( sigma ( u ), epsilon ( v )) * dx L = dot ( f , v ) * dx u = Function ( U ) print ( \"Number of degree's of freedom {} \" . format ( U . dim ())) problem = LinearVariationalProblem ( a , L , u , bc ) return problem , u https://fenicsproject.org/pub/tutorial/html/._ftut1017.html |Solver | Description | | | Preconditioner |Description | | -- |--|--|--|--|--| | bicgstab | Biconjugate gradient stabilized method| | | amg | Algebraic multigrid| | cg | Conjugate gradient method| | | default | default preconditioner| | default | default linear solver| | | hypre_amg | Hypre algebraic multigrid (BoomerAMG)| | gmres | Generalized minimal residual method| | | hypre_euclid | Hypre parallel incomplete LU factorization| | minres | Minimal residual method| | | hypre_parasails | Hypre parallel sparse approximate inverse| | mumps | MUMPS (MUltifrontal Massively Parallel Sparse direct Solver)| | | icc | Incomplete Cholesky factorization| | petsc | PETSc built in LU solver| | | ilu | Incomplete LU factorization| | richardson | Richardson method| | | jacobi | Jacobi iteration| | superlu | SuperLU| | | none | No preconditioner| | tfqmr | Transpose-free quasi-minimal residual method| | | petsc_amg | PETSc algebraic multigrid| | umfpack | UMFPACK (Unsymmetric MultiFrontal sparse LU factorization)| | | sor | Successive over-relaxation| problem , u = elasticity_problem ( num_ele_along_depth = 30 ) solver = LinearVariationalSolver ( problem ) prm = solver . parameters prm [ 'linear_solver' ] = 'cg' prm [ 'preconditioner' ] = 'ilu' prm [ 'krylov_solver' ][ 'absolute_tolerance' ] = 1E-9 prm [ 'krylov_solver' ][ 'relative_tolerance' ] = 1E-9 prm [ 'krylov_solver' ][ 'maximum_iterations' ] = 1000 solver . solve () print ( \"The minimum displacement is: {0:6.3e} m\" . format ( u . vector () . min ())) Number of degree's of freedom 18662 The minimum displacement is: -4.712e-04 m The minimum displacement is: -4.71e-04 m For each parameter variation, record the solver parameters used and the corresponding solution time and differnce in the minimum displacement. Compare the results obtained with different solver parameters. Analyze how the solution time and accuracy are affected by varying the solver parameters. Based on your observations, discuss which solver parameter(s) seem to have the most significant impact on solution accuracy and computational time. Consider the trade-offs between accuracy and computation time when choosing different solver configurations. Task 1: Considering num_ele_along_depth=30 , change the tolerance to 1E-5. What difference do you observe in the solution? Task 2: Now change the preconditioner to hypre_euclid . What happens to the solution? Task 3: Change the preconditioner to none and see what happens Task 4: Change the solver to mumps and see what happens","title":"3_solver_design.md"},{"location":"2_notebooks/day-3/exercises/3_solver_design/#solver-design","text":"The success of tackling complex problems often relies on the effectiveness of the solver employed. While formulating the mathematical model is crucial, paying attention to the design of an efficient and accurate solver is equally vital, as it directly impacts the quality and reliability of the results you obtain. In this exercise you will study the impact of different solver parameters on the solution. from dolfin import * def elasticity_problem ( num_ele_along_depth = 30 ): length , depth = 3 , .300 ele_size = depth / num_ele_along_depth mesh = RectangleMesh ( Point ( 0 , 0 ), Point ( length , depth ), int ( length / ele_size ), int ( depth / ele_size )) U = VectorFunctionSpace ( mesh , 'CG' , 1 ) dim = mesh . topology () . dim () clamped_boundary = CompiledSubDomain ( \"near(x[0],0)\" ) bc = DirichletBC ( U , Constant (( 0 ,) * dim ), clamped_boundary ) E , nu = 2e11 , 0.3 rho , g = 7800 , 9.81 lmbda = ( E * nu ) / (( 1 + nu ) * ( 1 - 2 * nu )) mu = E / ( 2 * ( 1 + nu )) def epsilon ( u ): return 0.5 * ( grad ( u ) + grad ( u ) . T ) def sigma ( u ): return lmbda * tr ( epsilon ( u )) * Identity ( dim ) + 2 * mu * epsilon ( u ) # Define variational problem u , v = TrialFunction ( U ), TestFunction ( U ) f = Constant (( 0 , - rho * g )) a = inner ( sigma ( u ), epsilon ( v )) * dx L = dot ( f , v ) * dx u = Function ( U ) print ( \"Number of degree's of freedom {} \" . format ( U . dim ())) problem = LinearVariationalProblem ( a , L , u , bc ) return problem , u https://fenicsproject.org/pub/tutorial/html/._ftut1017.html |Solver | Description | | | Preconditioner |Description | | -- |--|--|--|--|--| | bicgstab | Biconjugate gradient stabilized method| | | amg | Algebraic multigrid| | cg | Conjugate gradient method| | | default | default preconditioner| | default | default linear solver| | | hypre_amg | Hypre algebraic multigrid (BoomerAMG)| | gmres | Generalized minimal residual method| | | hypre_euclid | Hypre parallel incomplete LU factorization| | minres | Minimal residual method| | | hypre_parasails | Hypre parallel sparse approximate inverse| | mumps | MUMPS (MUltifrontal Massively Parallel Sparse direct Solver)| | | icc | Incomplete Cholesky factorization| | petsc | PETSc built in LU solver| | | ilu | Incomplete LU factorization| | richardson | Richardson method| | | jacobi | Jacobi iteration| | superlu | SuperLU| | | none | No preconditioner| | tfqmr | Transpose-free quasi-minimal residual method| | | petsc_amg | PETSc algebraic multigrid| | umfpack | UMFPACK (Unsymmetric MultiFrontal sparse LU factorization)| | | sor | Successive over-relaxation| problem , u = elasticity_problem ( num_ele_along_depth = 30 ) solver = LinearVariationalSolver ( problem ) prm = solver . parameters prm [ 'linear_solver' ] = 'cg' prm [ 'preconditioner' ] = 'ilu' prm [ 'krylov_solver' ][ 'absolute_tolerance' ] = 1E-9 prm [ 'krylov_solver' ][ 'relative_tolerance' ] = 1E-9 prm [ 'krylov_solver' ][ 'maximum_iterations' ] = 1000 solver . solve () print ( \"The minimum displacement is: {0:6.3e} m\" . format ( u . vector () . min ())) Number of degree's of freedom 18662 The minimum displacement is: -4.712e-04 m","title":"Solver design"},{"location":"2_notebooks/day-3/exercises/3_solver_design/#the-minimum-displacement-is-471e-04-m","text":"For each parameter variation, record the solver parameters used and the corresponding solution time and differnce in the minimum displacement. Compare the results obtained with different solver parameters. Analyze how the solution time and accuracy are affected by varying the solver parameters. Based on your observations, discuss which solver parameter(s) seem to have the most significant impact on solution accuracy and computational time. Consider the trade-offs between accuracy and computation time when choosing different solver configurations. Task 1: Considering num_ele_along_depth=30 , change the tolerance to 1E-5. What difference do you observe in the solution? Task 2: Now change the preconditioner to hypre_euclid . What happens to the solution? Task 3: Change the preconditioner to none and see what happens Task 4: Change the solver to mumps and see what happens","title":"The minimum displacement is: -4.71e-04 m"},{"location":"2_notebooks/day-3/tutorials/1_beam_bending/","text":"Linear Elasticity Linear elasticity is a fundamental theory in mechanics that describes the deformation of solid materials under the influence of external forces. It assumes that the deformation is small and that the relationship between stress and strain is linear. The theory is widely used in various engineering applications, such as structural analysis and material design. FEniCS provides a flexible and efficient platform for implementing finite element methods, making it an excellent choice for solving problems in linear elasticity. from dolfin import * from matplotlib import pyplot as plt length , depth = 3 , .300 num_ele_along_depth = 10 ele_size = depth / num_ele_along_depth mesh = RectangleMesh ( Point ( 0 , 0 ), Point ( length , depth ), int ( length / ele_size ), int ( depth / ele_size )) Different spaces in FEniCS In FEniCS, a \"space\" is a mathematical construct that contains functions used to approximate the quantities of interest (e.g. displacement, strain, stress, force etc). Different types of function spaces are used depending on the nature of the problem and the type of field variable sought. Quantity Type Function Space Dimension Displacement ( u ) Vector VectorFunctionSpace 2D/3D Stress Second-order tensor TensorFunctionSpace 2D/3D Strain Second-order tensor TensorFunctionSpace 2D/3D Von Mises Stress Scalar FunctionSpace 1D Body Force Vector VectorFunctionSpace 2D/3D Surface Force Vector VectorFunctionSpace 2D/3D Surface Traction Second-order tensor TensorFunctionSpace 2D/3D Note: Von Mises stress is a scalar quantity and is represented using a scalar function space in FEniCS. The \"Dimension\" column still indicates the dimensionality of the problem (2D or 3D). The \"Type\" column specifies the mathematical nature of the quantity (e.g., vector, tensor, scalar). The \"Function Space\" column indicates the corresponding function space to represent the quantity in FEniCS. V = FunctionSpace ( mesh , 'CG' , 1 ) U = VectorFunctionSpace ( mesh , 'CG' , 1 ) T0 = TensorFunctionSpace ( mesh , 'DG' , 0 ) dim = mesh . topology () . dim () clamped_boundary = CompiledSubDomain ( \"near(x[0],0)\" ) bc = DirichletBC ( U , Constant (( 0 ,) * dim ), clamped_boundary ) E , nu = 2e11 , 0.3 rho , g = 7800 , 9.81 \\[ \\begin{align} \\sigma &= \\lambda\\,\\hbox{tr}\\,(\\varepsilon) I + 2\\mu\\varepsilon,\\\\ \\varepsilon &= \\frac{1}{2}\\left(\\nabla u + (\\nabla u)^{\\top}\\right), \\end{align} \\] lmbda = ( E * nu ) / (( 1 + nu ) * ( 1 - 2 * nu )) mu = E / ( 2 * ( 1 + nu )) def epsilon ( u ): return 0.5 * ( grad ( u ) + grad ( u ) . T ) def sigma ( u ): return lmbda * tr ( epsilon ( u )) * Identity ( dim ) + 2 * mu * epsilon ( u ) # Define variational problem u , v = TrialFunction ( U ), TestFunction ( U ) f = Constant (( 0 , - rho * g )) a = inner ( sigma ( u ), epsilon ( v )) * dx L = dot ( f , v ) * dx # Compute solution u = Function ( U ) solve ( a == L , u , bc ) plt . figure ( figsize = ( 18 , 16 )) # Plot solution scale_factor = 1000 plot ( u * scale_factor , title = 'Displacement' , mode = 'displacement' ) <matplotlib.collections.PolyCollection at 0x7fd27b5deac8> u . vector () . min () -0.0004555058526919105 plt . figure ( figsize = ( 18 , 16 )) # Plot stress s = sigma ( u ) - ( 1. / 3 ) * tr ( sigma ( u )) * Identity ( dim ) # deviatoric stress von_Mises = sqrt ( 3. / 2 * inner ( s , s )) von_Mises = project ( von_Mises , V ) plot ( von_Mises , title = 'Von Mises stress' ) <matplotlib.tri.tricontour.TriContourSet at 0x7fd27b46a6a0> plt . figure ( figsize = ( 18 , 16 )) # Compute magnitude of displacement u_magnitude = sqrt ( dot ( u , u )) u_magnitude = project ( u_magnitude , V ) plot ( u_magnitude , 'Displacement magnitude' ) print ( 'min/max u:' , u_magnitude . vector () . vec () . array . min (), u_magnitude . vector () . vec () . array . max ()) min/max u: -2.4213610711295385e-10 0.0004564935128009332 stress = project ( sigma ( u ), T0 ) plt . figure ( figsize = ( 18 , 16 )) plot ( stress [ 0 , 0 ], title = '$\\sigma_ {xx} $' ) <matplotlib.tri.tricontour.TriContourSet at 0x7fd27b2fc978> plt . figure ( figsize = ( 18 , 16 )) plot ( stress [ 0 , 1 ], title = '$\\sigma_ {xy} $' ) <matplotlib.tri.tricontour.TriContourSet at 0x7fd27b288160> plt . figure ( figsize = ( 18 , 16 )) plot ( stress [ 1 , 1 ], title = '$\\sigma_ {yy} $' ) <matplotlib.tri.tricontour.TriContourSet at 0x7fd27b21e898>","title":"1_beam_bending.md"},{"location":"2_notebooks/day-3/tutorials/1_beam_bending/#linear-elasticity","text":"Linear elasticity is a fundamental theory in mechanics that describes the deformation of solid materials under the influence of external forces. It assumes that the deformation is small and that the relationship between stress and strain is linear. The theory is widely used in various engineering applications, such as structural analysis and material design. FEniCS provides a flexible and efficient platform for implementing finite element methods, making it an excellent choice for solving problems in linear elasticity. from dolfin import * from matplotlib import pyplot as plt length , depth = 3 , .300 num_ele_along_depth = 10 ele_size = depth / num_ele_along_depth mesh = RectangleMesh ( Point ( 0 , 0 ), Point ( length , depth ), int ( length / ele_size ), int ( depth / ele_size ))","title":"Linear Elasticity"},{"location":"2_notebooks/day-3/tutorials/1_beam_bending/#different-spaces-in-fenics","text":"In FEniCS, a \"space\" is a mathematical construct that contains functions used to approximate the quantities of interest (e.g. displacement, strain, stress, force etc). Different types of function spaces are used depending on the nature of the problem and the type of field variable sought. Quantity Type Function Space Dimension Displacement ( u ) Vector VectorFunctionSpace 2D/3D Stress Second-order tensor TensorFunctionSpace 2D/3D Strain Second-order tensor TensorFunctionSpace 2D/3D Von Mises Stress Scalar FunctionSpace 1D Body Force Vector VectorFunctionSpace 2D/3D Surface Force Vector VectorFunctionSpace 2D/3D Surface Traction Second-order tensor TensorFunctionSpace 2D/3D Note: Von Mises stress is a scalar quantity and is represented using a scalar function space in FEniCS. The \"Dimension\" column still indicates the dimensionality of the problem (2D or 3D). The \"Type\" column specifies the mathematical nature of the quantity (e.g., vector, tensor, scalar). The \"Function Space\" column indicates the corresponding function space to represent the quantity in FEniCS. V = FunctionSpace ( mesh , 'CG' , 1 ) U = VectorFunctionSpace ( mesh , 'CG' , 1 ) T0 = TensorFunctionSpace ( mesh , 'DG' , 0 ) dim = mesh . topology () . dim () clamped_boundary = CompiledSubDomain ( \"near(x[0],0)\" ) bc = DirichletBC ( U , Constant (( 0 ,) * dim ), clamped_boundary ) E , nu = 2e11 , 0.3 rho , g = 7800 , 9.81 \\[ \\begin{align} \\sigma &= \\lambda\\,\\hbox{tr}\\,(\\varepsilon) I + 2\\mu\\varepsilon,\\\\ \\varepsilon &= \\frac{1}{2}\\left(\\nabla u + (\\nabla u)^{\\top}\\right), \\end{align} \\] lmbda = ( E * nu ) / (( 1 + nu ) * ( 1 - 2 * nu )) mu = E / ( 2 * ( 1 + nu )) def epsilon ( u ): return 0.5 * ( grad ( u ) + grad ( u ) . T ) def sigma ( u ): return lmbda * tr ( epsilon ( u )) * Identity ( dim ) + 2 * mu * epsilon ( u ) # Define variational problem u , v = TrialFunction ( U ), TestFunction ( U ) f = Constant (( 0 , - rho * g )) a = inner ( sigma ( u ), epsilon ( v )) * dx L = dot ( f , v ) * dx # Compute solution u = Function ( U ) solve ( a == L , u , bc ) plt . figure ( figsize = ( 18 , 16 )) # Plot solution scale_factor = 1000 plot ( u * scale_factor , title = 'Displacement' , mode = 'displacement' ) <matplotlib.collections.PolyCollection at 0x7fd27b5deac8> u . vector () . min () -0.0004555058526919105 plt . figure ( figsize = ( 18 , 16 )) # Plot stress s = sigma ( u ) - ( 1. / 3 ) * tr ( sigma ( u )) * Identity ( dim ) # deviatoric stress von_Mises = sqrt ( 3. / 2 * inner ( s , s )) von_Mises = project ( von_Mises , V ) plot ( von_Mises , title = 'Von Mises stress' ) <matplotlib.tri.tricontour.TriContourSet at 0x7fd27b46a6a0> plt . figure ( figsize = ( 18 , 16 )) # Compute magnitude of displacement u_magnitude = sqrt ( dot ( u , u )) u_magnitude = project ( u_magnitude , V ) plot ( u_magnitude , 'Displacement magnitude' ) print ( 'min/max u:' , u_magnitude . vector () . vec () . array . min (), u_magnitude . vector () . vec () . array . max ()) min/max u: -2.4213610711295385e-10 0.0004564935128009332 stress = project ( sigma ( u ), T0 ) plt . figure ( figsize = ( 18 , 16 )) plot ( stress [ 0 , 0 ], title = '$\\sigma_ {xx} $' ) <matplotlib.tri.tricontour.TriContourSet at 0x7fd27b2fc978> plt . figure ( figsize = ( 18 , 16 )) plot ( stress [ 0 , 1 ], title = '$\\sigma_ {xy} $' ) <matplotlib.tri.tricontour.TriContourSet at 0x7fd27b288160> plt . figure ( figsize = ( 18 , 16 )) plot ( stress [ 1 , 1 ], title = '$\\sigma_ {yy} $' ) <matplotlib.tri.tricontour.TriContourSet at 0x7fd27b21e898>","title":"Different spaces in FEniCS"},{"location":"2_notebooks/day-3/tutorials/2_load_and_boundary_conditions/","text":"Loads and boundary conditions The preceding tutorial focused on body forces. However, in situations where you need to apply traction force or a Dirichlet Boundary Condition (DBC) to specific parts of the mesh, this tutorial will address those scenarios. from dolfin import * Mesh entities Conceptually, a mesh (modeled by the class Mesh), consists of a collection of mesh entities. A mesh entity is a pair (d, i), where d is the topological dimension of the mesh entity and i is a unique index of the mesh entity. Mesh entities are numbered within each topological dimension from 0 to nd \u2212 1, where nd is the number of mesh entities of topological dimension d. Entity Dimension Vertex 0 Edge 1 Face 2 Facet D-1 Cell D length, depth = .6, .200 num_ele_along_depth = 10 ele_size = depth/num_ele_along_depth mesh = RectangleMesh(Point(0, 0), Point(length, depth), int(length/ele_size), int(depth/ele_size)) V = FunctionSpace(mesh, 'CG', 1) U = VectorFunctionSpace(mesh, 'CG', 1) T0 = TensorFunctionSpace(mesh, 'DG', 0) dim = mesh.topology().dim() Define the boundaries (Subdomains) clamped_boundary = CompiledSubDomain(\"near(x[0],0)\") load_boundary = CompiledSubDomain(\"near(x[1],0.2) && x[0]>0.5\") Mark the boundaries on mesh support_tag, load_tag = 1, 2 mf = MeshFunction(\"size_t\", mesh, 1) mf.set_all(0) clamped_boundary.mark(mf,support_tag) load_boundary.mark(mf,load_tag) Visualize the boundaries with XDMFFile(\"input/subdomains.xdmf\") as outfile: outfile.write(mf) bc = DirichletBC(U, Constant((0,)*dim), clamped_boundary) E, nu = 2e11, 0.3 rho, g = 7800, 9.81 \\[ \\begin{align} \\sigma &= \\lambda\\,\\hbox{tr}\\,(\\varepsilon) I + 2\\mu\\varepsilon,\\\\ \\varepsilon &= \\frac{1}{2}\\left(\\nabla u + (\\nabla u)^{\\top}\\right), \\end{align} \\] lmbda = (E * nu) / ((1 + nu) * (1 - 2 * nu)) mu = E / (2 * (1 + nu)) def epsilon(u): return 0.5*(grad(u) + grad(u).T) def sigma(u): return lmbda*tr(epsilon(u))*Identity(dim) + 2*mu*epsilon(u) # Define variational problem u, v = TrialFunction(U), TestFunction(U) f = Constant((0, -rho*g)) ds = Measure(\"ds\",subdomain_data=mf) a = inner(sigma(u), epsilon(v))*dx t = Constant((0,100)) L = dot(f, v)*dx + dot(t,v)*ds(load_tag) # Compute solution u = Function(U) solve(a == L, u, bc) plt.figure(figsize=(18, 16)) # Plot solution scale_factor = 1e5 plot(u*scale_factor, title='Displacement', mode='displacement') <matplotlib.collections.PolyCollection at 0x7f38d4d042b0> u.vector().min() -1.8010419648112784e-06 plt.figure(figsize=(18, 16)) # Plot stress s = sigma(u) - (1./3)*tr(sigma(u))*Identity(dim) # deviatoric stress von_Mises = sqrt(3./2*inner(s, s)) von_Mises = project(von_Mises, V) plot(von_Mises, title='Von Mises stress') <matplotlib.tri.tricontour.TriContourSet at 0x7f38d4c3d1d0> plt.figure(figsize=(18, 16)) # Compute magnitude of displacement u_magnitude = sqrt(dot(u, u)) u_magnitude = project(u_magnitude, V) plot(u_magnitude, 'Displacement magnitude') print('min/max u:', u_magnitude.vector().vec().array.min(), u_magnitude.vector().vec().array.max()) min/max u: -5.71041349380966e-13 1.8360022678476485e-06 stress = project(sigma(u),T0) plt.figure(figsize=(18, 16)) plot(stress[0,0], title='$\\sigma_{xx}$') <matplotlib.tri.tricontour.TriContourSet at 0x7f38d4af0b38> plt.figure(figsize=(18, 16)) plot(stress[0,1], title='$\\sigma_{xy}$') <matplotlib.tri.tricontour.TriContourSet at 0x7f38d4a8ad68> plt.figure(figsize=(18, 16)) plot(stress[1,1], title='$\\sigma_{yy}$') <matplotlib.tri.tricontour.TriContourSet at 0x7f38d4a100f0>","title":"2_load_and_boundary_conditions.md"},{"location":"2_notebooks/day-3/tutorials/2_load_and_boundary_conditions/#loads-and-boundary-conditions","text":"The preceding tutorial focused on body forces. However, in situations where you need to apply traction force or a Dirichlet Boundary Condition (DBC) to specific parts of the mesh, this tutorial will address those scenarios. from dolfin import *","title":"Loads and boundary conditions"},{"location":"2_notebooks/day-3/tutorials/2_load_and_boundary_conditions/#mesh-entities","text":"Conceptually, a mesh (modeled by the class Mesh), consists of a collection of mesh entities. A mesh entity is a pair (d, i), where d is the topological dimension of the mesh entity and i is a unique index of the mesh entity. Mesh entities are numbered within each topological dimension from 0 to nd \u2212 1, where nd is the number of mesh entities of topological dimension d. Entity Dimension Vertex 0 Edge 1 Face 2 Facet D-1 Cell D length, depth = .6, .200 num_ele_along_depth = 10 ele_size = depth/num_ele_along_depth mesh = RectangleMesh(Point(0, 0), Point(length, depth), int(length/ele_size), int(depth/ele_size)) V = FunctionSpace(mesh, 'CG', 1) U = VectorFunctionSpace(mesh, 'CG', 1) T0 = TensorFunctionSpace(mesh, 'DG', 0) dim = mesh.topology().dim()","title":"Mesh entities"},{"location":"2_notebooks/day-3/tutorials/2_load_and_boundary_conditions/#define-the-boundaries-subdomains","text":"clamped_boundary = CompiledSubDomain(\"near(x[0],0)\") load_boundary = CompiledSubDomain(\"near(x[1],0.2) && x[0]>0.5\")","title":"Define the boundaries (Subdomains)"},{"location":"2_notebooks/day-3/tutorials/2_load_and_boundary_conditions/#mark-the-boundaries-on-mesh","text":"support_tag, load_tag = 1, 2 mf = MeshFunction(\"size_t\", mesh, 1) mf.set_all(0) clamped_boundary.mark(mf,support_tag) load_boundary.mark(mf,load_tag)","title":"Mark the boundaries on mesh"},{"location":"2_notebooks/day-3/tutorials/2_load_and_boundary_conditions/#visualize-the-boundaries","text":"with XDMFFile(\"input/subdomains.xdmf\") as outfile: outfile.write(mf) bc = DirichletBC(U, Constant((0,)*dim), clamped_boundary) E, nu = 2e11, 0.3 rho, g = 7800, 9.81 \\[ \\begin{align} \\sigma &= \\lambda\\,\\hbox{tr}\\,(\\varepsilon) I + 2\\mu\\varepsilon,\\\\ \\varepsilon &= \\frac{1}{2}\\left(\\nabla u + (\\nabla u)^{\\top}\\right), \\end{align} \\] lmbda = (E * nu) / ((1 + nu) * (1 - 2 * nu)) mu = E / (2 * (1 + nu)) def epsilon(u): return 0.5*(grad(u) + grad(u).T) def sigma(u): return lmbda*tr(epsilon(u))*Identity(dim) + 2*mu*epsilon(u) # Define variational problem u, v = TrialFunction(U), TestFunction(U) f = Constant((0, -rho*g)) ds = Measure(\"ds\",subdomain_data=mf) a = inner(sigma(u), epsilon(v))*dx t = Constant((0,100)) L = dot(f, v)*dx + dot(t,v)*ds(load_tag) # Compute solution u = Function(U) solve(a == L, u, bc) plt.figure(figsize=(18, 16)) # Plot solution scale_factor = 1e5 plot(u*scale_factor, title='Displacement', mode='displacement') <matplotlib.collections.PolyCollection at 0x7f38d4d042b0> u.vector().min() -1.8010419648112784e-06 plt.figure(figsize=(18, 16)) # Plot stress s = sigma(u) - (1./3)*tr(sigma(u))*Identity(dim) # deviatoric stress von_Mises = sqrt(3./2*inner(s, s)) von_Mises = project(von_Mises, V) plot(von_Mises, title='Von Mises stress') <matplotlib.tri.tricontour.TriContourSet at 0x7f38d4c3d1d0> plt.figure(figsize=(18, 16)) # Compute magnitude of displacement u_magnitude = sqrt(dot(u, u)) u_magnitude = project(u_magnitude, V) plot(u_magnitude, 'Displacement magnitude') print('min/max u:', u_magnitude.vector().vec().array.min(), u_magnitude.vector().vec().array.max()) min/max u: -5.71041349380966e-13 1.8360022678476485e-06 stress = project(sigma(u),T0) plt.figure(figsize=(18, 16)) plot(stress[0,0], title='$\\sigma_{xx}$') <matplotlib.tri.tricontour.TriContourSet at 0x7f38d4af0b38> plt.figure(figsize=(18, 16)) plot(stress[0,1], title='$\\sigma_{xy}$') <matplotlib.tri.tricontour.TriContourSet at 0x7f38d4a8ad68> plt.figure(figsize=(18, 16)) plot(stress[1,1], title='$\\sigma_{yy}$') <matplotlib.tri.tricontour.TriContourSet at 0x7f38d4a100f0>","title":"Visualize the boundaries"},{"location":"2_notebooks/day-3/tutorials/3_solver/","text":"Solver Design In addition to the standard solve method, FEniCS offers a powerful tool called the LinearVariationalSolver , which grants users the ability to finely adjust and control various parameters of the solver . This enhanced control allows for precise customization and optimization of the solver's behavior, leading to improved accuracy and efficiency in solving partial differential equations. In this tutorial you will learn how to define a Linear variational problem and modify the solver parameters. from dolfin import * length , depth = 3 , .300 num_ele_along_depth = 300 ele_size = depth / num_ele_along_depth mesh = RectangleMesh ( Point ( 0 , 0 ), Point ( length , depth ), int ( length / ele_size ), int ( depth / ele_size )) U = VectorFunctionSpace ( mesh , 'CG' , 1 ) dim = mesh . topology () . dim () clamped_boundary = CompiledSubDomain ( \"near(x[0],0)\" ) bc = DirichletBC ( U , Constant (( 0 ,) * dim ), clamped_boundary ) E , nu = 2e11 , 0.3 rho , g = 7800 , 9.81 lmbda = ( E * nu ) / (( 1 + nu ) * ( 1 - 2 * nu )) mu = E / ( 2 * ( 1 + nu )) def epsilon ( u ): return 0.5 * ( grad ( u ) + grad ( u ) . T ) def sigma ( u ): return lmbda * tr ( epsilon ( u )) * Identity ( dim ) + 2 * mu * epsilon ( u ) # Define variational problem u , v = TrialFunction ( U ), TestFunction ( U ) f = Constant (( 0 , - rho * g )) a = inner ( sigma ( u ), epsilon ( v )) * dx L = dot ( f , v ) * dx u = Function ( U ) print ( \"Number of degree's of freedom {} \" . format ( U . dim ())) Number of degree's of freedom 1806602 # Compute solution solve ( a == L , u , bc ) u . vector () . min () --------------------------------------------------------------------------- RuntimeError Traceback (most recent call last) <ipython-input-118-fed64cb3fd67> in <module> 1 # Compute solution 2 u = Function(U) ----> 3 solve(a == L, u, bc) 4 u.vector().min() /usr/local/lib/python3.6/dist-packages/dolfin/fem/solving.py in solve(*args, **kwargs) 218 # tolerance) 219 elif isinstance(args[0], ufl.classes.Equation): --> 220 _solve_varproblem(*args, **kwargs) 221 222 # Default case, just call the wrapped C++ solve function /usr/local/lib/python3.6/dist-packages/dolfin/fem/solving.py in _solve_varproblem(*args, **kwargs) 245 solver = LinearVariationalSolver(problem) 246 solver.parameters.update(solver_parameters) --> 247 solver.solve() 248 249 # Solve nonlinear variational problem RuntimeError: *** ------------------------------------------------------------------------- *** DOLFIN encountered an error. If you are not able to resolve this issue *** using the information listed below, you can ask for help at *** *** fenics-support@googlegroups.com *** *** Remember to include the error message listed below and, if possible, *** include a *minimal* running example to reproduce the error. *** *** ------------------------------------------------------------------------- *** Error: Unable to successfully call PETSc function 'KSPSolve'. *** Reason: PETSc error code is: 76 (Error in external library). *** Where: This error was encountered inside /tmp/dolfin/dolfin/la/PETScKrylovSolver.cpp. *** Process: 0 *** *** DOLFIN version: 2019.1.0 *** Git changeset: 74d7efe1e84d65e9433fd96c50f1d278fa3e3f3f *** ------------------------------------------------------------------------- FEniCS' standard solve method relies on a direct solver, which proves inadequate for computing solutions in systems with degrees of freedom exceeding approximately one million. To address this limitation, iterative solvers and preconditioners become necessary alternatives to efficiently handle large-scale problems. By employing these techniques, FEniCS enables the successful computation of solutions in scenarios where the direct solver falls short, making it a valuable tool for tackling complex simulations and high-dimensional models. problem = LinearVariationalProblem ( a , L , u , bc ) solver = LinearVariationalSolver ( problem ) prm = solver . parameters prm [ 'linear_solver' ] = 'cg' prm [ 'preconditioner' ] = 'hypre_euclid' prm [ 'krylov_solver' ][ 'absolute_tolerance' ] = 1E-5 prm [ 'krylov_solver' ][ 'relative_tolerance' ] = 1E-5 prm [ 'krylov_solver' ][ 'maximum_iterations' ] = 1000 solver . solve () print ( \"The minimum displacement is: {0:6.3e} m\" . format ( u . vector () . min ())) The minimum displacement is: -4.733e-04 m","title":"3_solver.md"},{"location":"2_notebooks/day-3/tutorials/3_solver/#solver-design","text":"In addition to the standard solve method, FEniCS offers a powerful tool called the LinearVariationalSolver , which grants users the ability to finely adjust and control various parameters of the solver . This enhanced control allows for precise customization and optimization of the solver's behavior, leading to improved accuracy and efficiency in solving partial differential equations. In this tutorial you will learn how to define a Linear variational problem and modify the solver parameters. from dolfin import * length , depth = 3 , .300 num_ele_along_depth = 300 ele_size = depth / num_ele_along_depth mesh = RectangleMesh ( Point ( 0 , 0 ), Point ( length , depth ), int ( length / ele_size ), int ( depth / ele_size )) U = VectorFunctionSpace ( mesh , 'CG' , 1 ) dim = mesh . topology () . dim () clamped_boundary = CompiledSubDomain ( \"near(x[0],0)\" ) bc = DirichletBC ( U , Constant (( 0 ,) * dim ), clamped_boundary ) E , nu = 2e11 , 0.3 rho , g = 7800 , 9.81 lmbda = ( E * nu ) / (( 1 + nu ) * ( 1 - 2 * nu )) mu = E / ( 2 * ( 1 + nu )) def epsilon ( u ): return 0.5 * ( grad ( u ) + grad ( u ) . T ) def sigma ( u ): return lmbda * tr ( epsilon ( u )) * Identity ( dim ) + 2 * mu * epsilon ( u ) # Define variational problem u , v = TrialFunction ( U ), TestFunction ( U ) f = Constant (( 0 , - rho * g )) a = inner ( sigma ( u ), epsilon ( v )) * dx L = dot ( f , v ) * dx u = Function ( U ) print ( \"Number of degree's of freedom {} \" . format ( U . dim ())) Number of degree's of freedom 1806602 # Compute solution solve ( a == L , u , bc ) u . vector () . min () --------------------------------------------------------------------------- RuntimeError Traceback (most recent call last) <ipython-input-118-fed64cb3fd67> in <module> 1 # Compute solution 2 u = Function(U) ----> 3 solve(a == L, u, bc) 4 u.vector().min() /usr/local/lib/python3.6/dist-packages/dolfin/fem/solving.py in solve(*args, **kwargs) 218 # tolerance) 219 elif isinstance(args[0], ufl.classes.Equation): --> 220 _solve_varproblem(*args, **kwargs) 221 222 # Default case, just call the wrapped C++ solve function /usr/local/lib/python3.6/dist-packages/dolfin/fem/solving.py in _solve_varproblem(*args, **kwargs) 245 solver = LinearVariationalSolver(problem) 246 solver.parameters.update(solver_parameters) --> 247 solver.solve() 248 249 # Solve nonlinear variational problem RuntimeError: *** ------------------------------------------------------------------------- *** DOLFIN encountered an error. If you are not able to resolve this issue *** using the information listed below, you can ask for help at *** *** fenics-support@googlegroups.com *** *** Remember to include the error message listed below and, if possible, *** include a *minimal* running example to reproduce the error. *** *** ------------------------------------------------------------------------- *** Error: Unable to successfully call PETSc function 'KSPSolve'. *** Reason: PETSc error code is: 76 (Error in external library). *** Where: This error was encountered inside /tmp/dolfin/dolfin/la/PETScKrylovSolver.cpp. *** Process: 0 *** *** DOLFIN version: 2019.1.0 *** Git changeset: 74d7efe1e84d65e9433fd96c50f1d278fa3e3f3f *** -------------------------------------------------------------------------","title":"Solver Design"},{"location":"2_notebooks/day-3/tutorials/3_solver/#fenics-standard-solve-method-relies-on-a-direct-solver-which-proves-inadequate-for-computing-solutions-in-systems-with-degrees-of-freedom-exceeding-approximately-one-million-to-address-this-limitation-iterative-solvers-and-preconditioners-become-necessary-alternatives-to-efficiently-handle-large-scale-problems-by-employing-these-techniques-fenics-enables-the-successful-computation-of-solutions-in-scenarios-where-the-direct-solver-falls-short-making-it-a-valuable-tool-for-tackling-complex-simulations-and-high-dimensional-models","text":"problem = LinearVariationalProblem ( a , L , u , bc ) solver = LinearVariationalSolver ( problem ) prm = solver . parameters prm [ 'linear_solver' ] = 'cg' prm [ 'preconditioner' ] = 'hypre_euclid' prm [ 'krylov_solver' ][ 'absolute_tolerance' ] = 1E-5 prm [ 'krylov_solver' ][ 'relative_tolerance' ] = 1E-5 prm [ 'krylov_solver' ][ 'maximum_iterations' ] = 1000 solver . solve () print ( \"The minimum displacement is: {0:6.3e} m\" . format ( u . vector () . min ())) The minimum displacement is: -4.733e-04 m","title":"FEniCS' standard solve method relies on a direct solver, which proves inadequate for computing solutions in systems with degrees of freedom exceeding approximately one million. To address this limitation, iterative solvers and preconditioners become necessary alternatives to efficiently handle large-scale problems. By employing these techniques, FEniCS enables the successful computation of solutions in scenarios where the direct solver falls short, making it a valuable tool for tackling complex simulations and high-dimensional models."},{"location":"2_notebooks/day-4/exercises/1_mooney-rivlin/","text":"from dolfin import * from matplotlib import pyplot as plt # Create mesh and define function space length , depth = 3000 , 300 num_ele_along_depth = 10 ele_size = depth / num_ele_along_depth mesh = RectangleMesh ( Point ( 0 , 0 ), Point ( length , depth ), int ( length / ele_size ), int ( depth / ele_size )) V = VectorFunctionSpace ( mesh , \"Lagrange\" , 1 ) # Mark boundary subdomians clamped_boundary = CompiledSubDomain ( \"near(x[0],0)\" ) load_boundary = CompiledSubDomain ( \"near(x[0],3000)\" ) # Define Dirichlet boundary (x = 0 or x = 1) c = Expression (( \"0.0\" , \"0.0\" ), degree = 1 ) r = Expression (( \"-disp_step*t\" ), disp_step = 100 , t = 1 , degree = 1 ) bcl = DirichletBC ( V , c , clamped_boundary ) bcr = DirichletBC ( V . sub ( 1 ), r , load_boundary ) bcs = [ bcl , bcr ] # Define functions du = TrialFunction ( V ) # Incremental displacement v = TestFunction ( V ) # Test function u = Function ( V ) # Displacement from previous iteration B = Constant (( 0.0 , 0.0 )) # Body force per unit volume T = Constant (( 0.0 , 0.0 )) # Traction force on the boundary # Kinematics d = u . geometric_dimension () I = Identity ( d ) # Identity tensor F = I + grad ( u ) # Deformation gradient C = F . T * F # Right Cauchy-Green tensor # Invariants of deformation tensors Ic = tr ( C ) J = det ( F ) https://iopscience.iop.org/article/10.1088/1742-6596/1741/1/012047/pdf # Elasticity parameters E , nu = 20 , 0.4995 mu , lmbda = ( E / ( 2 * ( 1 + nu ))), ( E * nu / (( 1 + nu ) * ( 1 - 2 * nu ))) # Define the material parameters c10 = Constant ( 3.47 ) # Mooney-Rivlin parameter C10 c01 = Constant ( 0.69 ) # Mooney-Rivlin parameter C01 D1 = Constant ( 0.00028 ) # Define the Mooney-Rivlin strain-energy density function I1 = tr ( C ) I2 = 0.5 * ( tr ( C ) ** 2 - tr ( C * C )) psi = c10 * ( I1 - 3 ) + c01 * ( I2 - 3 ) + 1 / D1 * ( J - 1 ) ** 2 # Stored strain energy density (compressible neo-Hookean model) # psi = (mu/2)*(Ic - 3) - mu*ln(J) + (lmbda/2)*(ln(J))**2 # Total potential energy Pi = psi * dx - dot ( B , u ) * dx - dot ( T , u ) * ds # Compute first variation of Pi (directional derivative about u in the direction of v) F = derivative ( Pi , u , v ) # Compute Jacobian of F J = derivative ( F , u , du ) # Compute solution problem = NonlinearVariationalProblem ( F , u , bcs , J ) solver = NonlinearVariationalSolver ( problem ) prm = solver . parameters prm [ 'newton_solver' ][ 'absolute_tolerance' ] = 1E-7 prm [ 'newton_solver' ][ 'relative_tolerance' ] = 1E-7 prm [ 'newton_solver' ][ 'maximum_iterations' ] = 1000 prm [ 'newton_solver' ][ 'linear_solver' ] = 'gmres' prm [ 'newton_solver' ][ 'preconditioner' ] = 'hypre_euclid' prm [ 'newton_solver' ][ 'krylov_solver' ][ 'absolute_tolerance' ] = 1E-7 prm [ 'newton_solver' ][ 'krylov_solver' ][ 'relative_tolerance' ] = 1E-7 prm [ 'newton_solver' ][ 'krylov_solver' ][ 'maximum_iterations' ] = 1000 solver . solve () print ( \"The minimum displacement is: {0:6.3e} mm\" . format ( u . vector () . min ())) plt . figure ( figsize = ( 18 , 16 )) # Plot solution scale_factor = 1 / 2 plot ( u * scale_factor , title = 'Displacement' , mode = 'displacement' ) <matplotlib.collections.PolyCollection at 0x7ff3893aedd8>","title":"1_mooney-rivlin.md"},{"location":"2_notebooks/day-4/exercises/2_comparison/","text":"Comparing linear elastic to hyper-elastic response In this exercise you have to compare the load-displacement response of linear elastic and hyperelastic models under the same loading condition. from dolfin import * from matplotlib import pyplot as plt # Create mesh and define function space def get_reaction_force ( mesh ): mf = MeshFunction ( \"size_t\" , mesh , 1 ) mf . set_all ( 0 ) clamped_boundary . mark ( mf , 1 ) ds = Measure ( \"ds\" , subdomain_data = mf ) # Define the Neumann boundary condition for the traction vector n = FacetNormal ( mesh ) traction = dot ( sigma ( u ), n ) # Integrate to get the traction vector reaction = assemble ( traction [ 1 ] * ds ( 1 )) return reaction Elastic def epsilon ( u ): return 0.5 * ( grad ( u ) + grad ( u ) . T ) def sigma ( u ): return lmbda * tr ( epsilon ( u )) * Identity ( dim ) + 2 * mu * epsilon ( u ) length , depth = 3000 , 300 num_ele_along_depth = 10 ele_size = depth / num_ele_along_depth mesh = RectangleMesh ( Point ( 0 , 0 ), Point ( length , depth ), int ( length / ele_size ), int ( depth / ele_size )) Mark boundary subdomians Mark the left edge as clamped_boundary and right edge as load_boundary clamped_boundary = load_boundary = U = VectorFunctionSpace ( mesh , 'CG' , 2 ) dim = mesh . topology () . dim () fixed = Expression (( \"0.0\" , \"0.0\" ), degree = 1 ) load = Expression (( \"-disp_step*t\" ), disp_step = 100 , t = 1 , degree = 1 ) bcl = DirichletBC ( U , fixed , clamped_boundary ) bcr = DirichletBC ( U . sub ( 1 ), load , load_boundary ) bc = [ bcl , bcr ] E , nu = 1 , 0.45 Define the Lame's parameters lmbda = mu = # Define variational problem u , v = TrialFunction ( U ), TestFunction ( U ) Set the body force to 0 and define the linear and bilenear forms of the linear elastic problem f = a = L = u = Function ( U ) problem = LinearVariationalProblem ( a , L , u , bc ) solver = LinearVariationalSolver ( problem ) elastic_reaction_force = [] elastic_displacement = [] for t in range ( 0 , 30 ): load . t = t solver . solve () elastic_displacement . append ( load . t * 100 ) elastic_reaction_force . append ( get_reaction_force ( mesh )) plt . figure ( figsize = ( 8 , 8 )) plt . plot ( elastic_displacement , elastic_reaction_force ) [<matplotlib.lines.Line2D at 0x7f671ffe3a58>] Hyperelastic Define the material model parameter. Check day-4, tutorial-1 def sigma ( u ): I = F = variable ( grad ( u ) + I ) J = C = I1 = energy = return 2 * diff ( energy , F ) # Define functions du = TrialFunction ( U ) # Incremental displacement v = TestFunction ( U ) # Test function u = Function ( U ) # Displacement from previous iteration B = Constant (( 0.0 , 0.0 )) # Body force per unit volume T = Constant (( 0.0 , 0.0 )) # Traction force on the boundary # Kinematics d = u . geometric_dimension () I = Identity ( d ) # Identity tensor F = C = # Invariants of deformation tensors Ic = J = # Stored strain energy density (compressible neo-Hookean model) psi = ( mu / 2 ) * ( Ic - 3 ) - mu * ln ( J ) + ( lmbda / 2 ) * ( ln ( J )) ** 2 # Total potential energy Pi = psi * dx - dot ( B , u ) * dx - dot ( T , u ) * ds # Compute first variation of Pi (directional derivative about u in the direction of v) F = derivative ( Pi , u , v ) # Compute Jacobian of F J = derivative ( F , u , du ) # Compute solution problem = NonlinearVariationalProblem ( F , u , bc , J ) solver = NonlinearVariationalSolver ( problem ) prm = solver . parameters prm [ 'newton_solver' ][ 'absolute_tolerance' ] = 1E-7 prm [ 'newton_solver' ][ 'relative_tolerance' ] = 1E-7 prm [ 'newton_solver' ][ 'maximum_iterations' ] = 1000 prm [ 'newton_solver' ][ 'linear_solver' ] = 'gmres' prm [ 'newton_solver' ][ 'preconditioner' ] = 'hypre_euclid' prm [ 'newton_solver' ][ 'krylov_solver' ][ 'absolute_tolerance' ] = 1E-7 prm [ 'newton_solver' ][ 'krylov_solver' ][ 'relative_tolerance' ] = 1E-7 prm [ 'newton_solver' ][ 'krylov_solver' ][ 'maximum_iterations' ] = 1000 reaction_force = [] displacement = [] for t in range ( 0 , 30 ): load . t = t solver . solve () displacement . append ( load . t * 100 ) reaction_force . append ( get_reaction_force ( mesh )) Calling FFC just-in-time (JIT) compiler, this may take some time. Calling FFC just-in-time (JIT) compiler, this may take some time. Calling FFC just-in-time (JIT) compiler, this may take some time. plt . figure ( figsize = ( 8 , 8 )) plt . plot ( displacement , reaction_force ) plt . plot ( elastic_displacement , elastic_reaction_force ) [<matplotlib.lines.Line2D at 0x7f671db7add8>]","title":"2_comparison.md"},{"location":"2_notebooks/day-4/exercises/2_comparison/#comparing-linear-elastic-to-hyper-elastic-response","text":"In this exercise you have to compare the load-displacement response of linear elastic and hyperelastic models under the same loading condition. from dolfin import * from matplotlib import pyplot as plt # Create mesh and define function space def get_reaction_force ( mesh ): mf = MeshFunction ( \"size_t\" , mesh , 1 ) mf . set_all ( 0 ) clamped_boundary . mark ( mf , 1 ) ds = Measure ( \"ds\" , subdomain_data = mf ) # Define the Neumann boundary condition for the traction vector n = FacetNormal ( mesh ) traction = dot ( sigma ( u ), n ) # Integrate to get the traction vector reaction = assemble ( traction [ 1 ] * ds ( 1 )) return reaction","title":"Comparing linear elastic to hyper-elastic response"},{"location":"2_notebooks/day-4/exercises/2_comparison/#elastic","text":"def epsilon ( u ): return 0.5 * ( grad ( u ) + grad ( u ) . T ) def sigma ( u ): return lmbda * tr ( epsilon ( u )) * Identity ( dim ) + 2 * mu * epsilon ( u ) length , depth = 3000 , 300 num_ele_along_depth = 10 ele_size = depth / num_ele_along_depth mesh = RectangleMesh ( Point ( 0 , 0 ), Point ( length , depth ), int ( length / ele_size ), int ( depth / ele_size ))","title":"Elastic"},{"location":"2_notebooks/day-4/exercises/2_comparison/#mark-boundary-subdomians","text":"Mark the left edge as clamped_boundary and right edge as load_boundary clamped_boundary = load_boundary = U = VectorFunctionSpace ( mesh , 'CG' , 2 ) dim = mesh . topology () . dim () fixed = Expression (( \"0.0\" , \"0.0\" ), degree = 1 ) load = Expression (( \"-disp_step*t\" ), disp_step = 100 , t = 1 , degree = 1 ) bcl = DirichletBC ( U , fixed , clamped_boundary ) bcr = DirichletBC ( U . sub ( 1 ), load , load_boundary ) bc = [ bcl , bcr ] E , nu = 1 , 0.45","title":"Mark boundary subdomians"},{"location":"2_notebooks/day-4/exercises/2_comparison/#define-the-lames-parameters","text":"lmbda = mu = # Define variational problem u , v = TrialFunction ( U ), TestFunction ( U )","title":"Define the Lame's parameters"},{"location":"2_notebooks/day-4/exercises/2_comparison/#set-the-body-force-to-0-and-define-the-linear-and-bilenear-forms-of-the-linear-elastic-problem","text":"f = a = L = u = Function ( U ) problem = LinearVariationalProblem ( a , L , u , bc ) solver = LinearVariationalSolver ( problem ) elastic_reaction_force = [] elastic_displacement = [] for t in range ( 0 , 30 ): load . t = t solver . solve () elastic_displacement . append ( load . t * 100 ) elastic_reaction_force . append ( get_reaction_force ( mesh )) plt . figure ( figsize = ( 8 , 8 )) plt . plot ( elastic_displacement , elastic_reaction_force ) [<matplotlib.lines.Line2D at 0x7f671ffe3a58>]","title":"Set the body force to 0 and define the linear and bilenear forms of the linear elastic problem"},{"location":"2_notebooks/day-4/exercises/2_comparison/#hyperelastic","text":"Define the material model parameter. Check day-4, tutorial-1 def sigma ( u ): I = F = variable ( grad ( u ) + I ) J = C = I1 = energy = return 2 * diff ( energy , F ) # Define functions du = TrialFunction ( U ) # Incremental displacement v = TestFunction ( U ) # Test function u = Function ( U ) # Displacement from previous iteration B = Constant (( 0.0 , 0.0 )) # Body force per unit volume T = Constant (( 0.0 , 0.0 )) # Traction force on the boundary # Kinematics d = u . geometric_dimension () I = Identity ( d ) # Identity tensor F = C = # Invariants of deformation tensors Ic = J = # Stored strain energy density (compressible neo-Hookean model) psi = ( mu / 2 ) * ( Ic - 3 ) - mu * ln ( J ) + ( lmbda / 2 ) * ( ln ( J )) ** 2 # Total potential energy Pi = psi * dx - dot ( B , u ) * dx - dot ( T , u ) * ds # Compute first variation of Pi (directional derivative about u in the direction of v) F = derivative ( Pi , u , v ) # Compute Jacobian of F J = derivative ( F , u , du ) # Compute solution problem = NonlinearVariationalProblem ( F , u , bc , J ) solver = NonlinearVariationalSolver ( problem ) prm = solver . parameters prm [ 'newton_solver' ][ 'absolute_tolerance' ] = 1E-7 prm [ 'newton_solver' ][ 'relative_tolerance' ] = 1E-7 prm [ 'newton_solver' ][ 'maximum_iterations' ] = 1000 prm [ 'newton_solver' ][ 'linear_solver' ] = 'gmres' prm [ 'newton_solver' ][ 'preconditioner' ] = 'hypre_euclid' prm [ 'newton_solver' ][ 'krylov_solver' ][ 'absolute_tolerance' ] = 1E-7 prm [ 'newton_solver' ][ 'krylov_solver' ][ 'relative_tolerance' ] = 1E-7 prm [ 'newton_solver' ][ 'krylov_solver' ][ 'maximum_iterations' ] = 1000 reaction_force = [] displacement = [] for t in range ( 0 , 30 ): load . t = t solver . solve () displacement . append ( load . t * 100 ) reaction_force . append ( get_reaction_force ( mesh )) Calling FFC just-in-time (JIT) compiler, this may take some time. Calling FFC just-in-time (JIT) compiler, this may take some time. Calling FFC just-in-time (JIT) compiler, this may take some time. plt . figure ( figsize = ( 8 , 8 )) plt . plot ( displacement , reaction_force ) plt . plot ( elastic_displacement , elastic_reaction_force ) [<matplotlib.lines.Line2D at 0x7f671db7add8>]","title":"Hyperelastic"},{"location":"2_notebooks/day-4/tutorials/1_hyper_elastic/","text":"Hyperelasticity Linear elasticity describes the mechanical response of materials under small deformations, following Hooke's Law with a linear stress-strain relationship. It is suitable for small deformation applications. Hyperelasticity, on the other hand, applies to materials undergoing large deformations with nonlinear stress-strain relationships. It involves complex mathematical models to capture their behavior accurately and is used for elastomers, soft polymers, biological tissues, and applications involving significant strain without permanent deformation. Go to the following link to understand the theory behind hyperelasticity: https://fenicsproject.org/olddocs/dolfin/1.6.0/python/demo/documented/hyperelasticity/python/documentation.html In this tutorial we will use the Neo-Hookean model to analyze large deformation in a cantilever beam made out of rubber. from dolfin import * from matplotlib import pyplot as plt # Create mesh and define function space length , depth = 3000 , 300 num_ele_along_depth = 10 ele_size = depth / num_ele_along_depth mesh = RectangleMesh ( Point ( 0 , 0 ), Point ( length , depth ), int ( length / ele_size ), int ( depth / ele_size )) V = VectorFunctionSpace ( mesh , \"Lagrange\" , 1 ) # Mark boundary subdomians clamped_boundary = CompiledSubDomain ( \"near(x[0],0)\" ) load_boundary = CompiledSubDomain ( \"near(x[0],3000)\" ) # Define Dirichlet boundary (x = 0 or x = 1) c = Expression (( \"0.0\" , \"0.0\" ), degree = 1 ) r = Expression (( \"-disp_step*t\" ), disp_step = 100 , t = 1 , degree = 1 ) bcl = DirichletBC ( V , c , clamped_boundary ) bcr = DirichletBC ( V . sub ( 1 ), r , load_boundary ) bcs = [ bcl , bcr ] # Define functions du = TrialFunction ( V ) # Incremental displacement v = TestFunction ( V ) # Test function u = Function ( V ) # Displacement from previous iteration B = Constant (( 0.0 , 0.0 )) # Body force per unit volume T = Constant (( 0.0 , 0.0 )) # Traction force on the boundary # Kinematics d = u . geometric_dimension () I = Identity ( d ) # Identity tensor F = I + grad ( u ) # Deformation gradient C = F . T * F # Right Cauchy-Green tensor # Invariants of deformation tensors Ic = tr ( C ) J = det ( F ) # Elasticity parameters E , nu = 1 , 0.45 mu , lmbda = Constant ( E / ( 2 * ( 1 + nu ))), Constant ( E * nu / (( 1 + nu ) * ( 1 - 2 * nu ))) # Stored strain energy density (compressible neo-Hookean model) psi = ( mu / 2 ) * ( Ic - 3 ) - mu * ln ( J ) + ( lmbda / 2 ) * ( ln ( J )) ** 2 # Total potential energy Pi = psi * dx - dot ( B , u ) * dx - dot ( T , u ) * ds # Compute first variation of Pi (directional derivative about u in the direction of v) F = derivative ( Pi , u , v ) # Compute Jacobian of F J = derivative ( F , u , du ) # Compute solution problem = NonlinearVariationalProblem ( F , u , bcs , J ) solver = NonlinearVariationalSolver ( problem ) prm = solver . parameters prm [ 'newton_solver' ][ 'absolute_tolerance' ] = 1E-7 prm [ 'newton_solver' ][ 'relative_tolerance' ] = 1E-7 prm [ 'newton_solver' ][ 'maximum_iterations' ] = 1000 prm [ 'newton_solver' ][ 'linear_solver' ] = 'gmres' prm [ 'newton_solver' ][ 'preconditioner' ] = 'hypre_euclid' prm [ 'newton_solver' ][ 'krylov_solver' ][ 'absolute_tolerance' ] = 1E-7 prm [ 'newton_solver' ][ 'krylov_solver' ][ 'relative_tolerance' ] = 1E-7 prm [ 'newton_solver' ][ 'krylov_solver' ][ 'maximum_iterations' ] = 1000 solver . solve () print ( \"The minimum displacement is: {0:6.3e} mm\" . format ( u . vector () . min ())) The minimum displacement is: -1.000e+02 mm plt . figure ( figsize = ( 18 , 16 )) # Plot solution scale_factor = 5 plot ( u * scale_factor , title = 'Displacement' , mode = 'displacement' ) Calling FFC just-in-time (JIT) compiler, this may take some time. <matplotlib.collections.PolyCollection at 0x7ff38a487320>","title":"1_hyper_elastic.md"},{"location":"2_notebooks/day-4/tutorials/1_hyper_elastic/#hyperelasticity","text":"Linear elasticity describes the mechanical response of materials under small deformations, following Hooke's Law with a linear stress-strain relationship. It is suitable for small deformation applications. Hyperelasticity, on the other hand, applies to materials undergoing large deformations with nonlinear stress-strain relationships. It involves complex mathematical models to capture their behavior accurately and is used for elastomers, soft polymers, biological tissues, and applications involving significant strain without permanent deformation. Go to the following link to understand the theory behind hyperelasticity: https://fenicsproject.org/olddocs/dolfin/1.6.0/python/demo/documented/hyperelasticity/python/documentation.html In this tutorial we will use the Neo-Hookean model to analyze large deformation in a cantilever beam made out of rubber. from dolfin import * from matplotlib import pyplot as plt # Create mesh and define function space length , depth = 3000 , 300 num_ele_along_depth = 10 ele_size = depth / num_ele_along_depth mesh = RectangleMesh ( Point ( 0 , 0 ), Point ( length , depth ), int ( length / ele_size ), int ( depth / ele_size )) V = VectorFunctionSpace ( mesh , \"Lagrange\" , 1 ) # Mark boundary subdomians clamped_boundary = CompiledSubDomain ( \"near(x[0],0)\" ) load_boundary = CompiledSubDomain ( \"near(x[0],3000)\" ) # Define Dirichlet boundary (x = 0 or x = 1) c = Expression (( \"0.0\" , \"0.0\" ), degree = 1 ) r = Expression (( \"-disp_step*t\" ), disp_step = 100 , t = 1 , degree = 1 ) bcl = DirichletBC ( V , c , clamped_boundary ) bcr = DirichletBC ( V . sub ( 1 ), r , load_boundary ) bcs = [ bcl , bcr ] # Define functions du = TrialFunction ( V ) # Incremental displacement v = TestFunction ( V ) # Test function u = Function ( V ) # Displacement from previous iteration B = Constant (( 0.0 , 0.0 )) # Body force per unit volume T = Constant (( 0.0 , 0.0 )) # Traction force on the boundary # Kinematics d = u . geometric_dimension () I = Identity ( d ) # Identity tensor F = I + grad ( u ) # Deformation gradient C = F . T * F # Right Cauchy-Green tensor # Invariants of deformation tensors Ic = tr ( C ) J = det ( F ) # Elasticity parameters E , nu = 1 , 0.45 mu , lmbda = Constant ( E / ( 2 * ( 1 + nu ))), Constant ( E * nu / (( 1 + nu ) * ( 1 - 2 * nu ))) # Stored strain energy density (compressible neo-Hookean model) psi = ( mu / 2 ) * ( Ic - 3 ) - mu * ln ( J ) + ( lmbda / 2 ) * ( ln ( J )) ** 2 # Total potential energy Pi = psi * dx - dot ( B , u ) * dx - dot ( T , u ) * ds # Compute first variation of Pi (directional derivative about u in the direction of v) F = derivative ( Pi , u , v ) # Compute Jacobian of F J = derivative ( F , u , du ) # Compute solution problem = NonlinearVariationalProblem ( F , u , bcs , J ) solver = NonlinearVariationalSolver ( problem ) prm = solver . parameters prm [ 'newton_solver' ][ 'absolute_tolerance' ] = 1E-7 prm [ 'newton_solver' ][ 'relative_tolerance' ] = 1E-7 prm [ 'newton_solver' ][ 'maximum_iterations' ] = 1000 prm [ 'newton_solver' ][ 'linear_solver' ] = 'gmres' prm [ 'newton_solver' ][ 'preconditioner' ] = 'hypre_euclid' prm [ 'newton_solver' ][ 'krylov_solver' ][ 'absolute_tolerance' ] = 1E-7 prm [ 'newton_solver' ][ 'krylov_solver' ][ 'relative_tolerance' ] = 1E-7 prm [ 'newton_solver' ][ 'krylov_solver' ][ 'maximum_iterations' ] = 1000 solver . solve () print ( \"The minimum displacement is: {0:6.3e} mm\" . format ( u . vector () . min ())) The minimum displacement is: -1.000e+02 mm plt . figure ( figsize = ( 18 , 16 )) # Plot solution scale_factor = 5 plot ( u * scale_factor , title = 'Displacement' , mode = 'displacement' ) Calling FFC just-in-time (JIT) compiler, this may take some time. <matplotlib.collections.PolyCollection at 0x7ff38a487320>","title":"Hyperelasticity"},{"location":"2_notebooks/day-4/tutorials/2_load_displacement/","text":"Pseudo-time analysis Hyperelastic materials experience substantial deformations, resulting in highly nonlinear responses. Pseudo time analysis facilitates the simulation of these significant deformations while ensuring numerical accuracy throughout the process. It addresses the inherent nonlinearity of the stress-strain relationship in hyperelastic materials. def sigma ( u ): I = Identity ( u . geometric_dimension ()) F = variable ( grad ( u ) + I ) J = det ( F ) C = F . T * F I1 = tr ( C ) energy = ( mu / 2 ) * ( I1 - 2 ) - mu * ln ( J ) + ( lmbda / 2 ) * ln ( J ) ** 2 return 2 * diff ( energy , F ) def get_reaction_force ( mesh ): mf = MeshFunction ( \"size_t\" , mesh , 1 ) mf . set_all ( 0 ) clamped_boundary . mark ( mf , 1 ) ds = Measure ( \"ds\" , subdomain_data = mf ) # Define the Neumann boundary condition for the traction vector n = FacetNormal ( mesh ) traction = dot ( sigma ( u ), n ) # Integrate to get the traction vector reaction = assemble ( traction [ 1 ] * ds ( 1 )) return reaction from dolfin import * from matplotlib import pyplot as plt # Create mesh and define function space length , depth = 3000 , 300 num_ele_along_depth = 10 ele_size = depth / num_ele_along_depth mesh = RectangleMesh ( Point ( 0 , 0 ), Point ( length , depth ), int ( length / ele_size ), int ( depth / ele_size )) V = VectorFunctionSpace ( mesh , \"Lagrange\" , 1 ) # Mark boundary subdomians clamped_boundary = CompiledSubDomain ( \"near(x[0],0)\" ) disp_boundary = CompiledSubDomain ( \"near(x[0],3000)\" ) # Define Dirichlet boundary (x = 0 or x = 1) fixed = Expression (( \"0.0\" , \"0.0\" ), degree = 1 ) disp = Expression (( \"-disp_step*t\" ), disp_step = 100 , t = 1 , degree = 1 ) bcl = DirichletBC ( V , fixed , clamped_boundary ) bcr = DirichletBC ( V . sub ( 1 ), disp , disp_boundary ) bcs = [ bcl , bcr ] # Define functions du = TrialFunction ( V ) # Incremental displacement v = TestFunction ( V ) # Test function u = Function ( V ) # Displacement from previous iteration B = Constant (( 0.0 , 0.0 )) # Body force per unit volume T = Constant (( 0.0 , 0.0 )) # Traction force on the boundary # Kinematics d = u . geometric_dimension () I = Identity ( d ) # Identity tensor F = I + grad ( u ) # Deformation gradient C = F . T * F # Right Cauchy-Green tensor # Invariants of deformation tensors Ic = tr ( C ) J = det ( F ) # Elasticity parameters E , nu = 1 , 0.45 mu , lmbda = Constant ( E / ( 2 * ( 1 + nu ))), Constant ( E * nu / (( 1 + nu ) * ( 1 - 2 * nu ))) # Stored strain energy density (compressible neo-Hookean model) psi = ( mu / 2 ) * ( Ic - 3 ) - mu * ln ( J ) + ( lmbda / 2 ) * ( ln ( J )) ** 2 # Total potential energy Pi = psi * dx - dot ( B , u ) * dx - dot ( T , u ) * ds # Compute first variation of Pi (directional derivative about u in the direction of v) F = derivative ( Pi , u , v ) # Compute Jacobian of F J = derivative ( F , u , du ) # Compute solution problem = NonlinearVariationalProblem ( F , u , bcs , J ) solver = NonlinearVariationalSolver ( problem ) prm = solver . parameters prm [ 'newton_solver' ][ 'absolute_tolerance' ] = 1E-7 prm [ 'newton_solver' ][ 'relative_tolerance' ] = 1E-7 prm [ 'newton_solver' ][ 'maximum_iterations' ] = 1000 prm [ 'newton_solver' ][ 'linear_solver' ] = 'gmres' prm [ 'newton_solver' ][ 'preconditioner' ] = 'hypre_euclid' prm [ 'newton_solver' ][ 'krylov_solver' ][ 'absolute_tolerance' ] = 1E-7 prm [ 'newton_solver' ][ 'krylov_solver' ][ 'relative_tolerance' ] = 1E-7 prm [ 'newton_solver' ][ 'krylov_solver' ][ 'maximum_iterations' ] = 1000 reaction_force = [] displacement = [] for t in range ( 0 , 30 ): disp . t = t solver . solve () displacement . append ( disp . t * 100 ) reaction_force . append ( get_reaction_force ( mesh )) plt . figure ( figsize = ( 8 , 8 )) plt . plot ( displacement , reaction_force ) [<matplotlib.lines.Line2D at 0x7f3c7917b940>] plt . figure ( figsize = ( 18 , 16 )) # Plot solution scale_factor = 1 / 10 plot ( u * scale_factor , title = 'Displacement' , mode = 'displacement' ) <matplotlib.collections.PolyCollection at 0x7f3c78fc6390>","title":"2_load_displacement.md"},{"location":"2_notebooks/day-4/tutorials/2_load_displacement/#pseudo-time-analysis","text":"Hyperelastic materials experience substantial deformations, resulting in highly nonlinear responses. Pseudo time analysis facilitates the simulation of these significant deformations while ensuring numerical accuracy throughout the process. It addresses the inherent nonlinearity of the stress-strain relationship in hyperelastic materials. def sigma ( u ): I = Identity ( u . geometric_dimension ()) F = variable ( grad ( u ) + I ) J = det ( F ) C = F . T * F I1 = tr ( C ) energy = ( mu / 2 ) * ( I1 - 2 ) - mu * ln ( J ) + ( lmbda / 2 ) * ln ( J ) ** 2 return 2 * diff ( energy , F ) def get_reaction_force ( mesh ): mf = MeshFunction ( \"size_t\" , mesh , 1 ) mf . set_all ( 0 ) clamped_boundary . mark ( mf , 1 ) ds = Measure ( \"ds\" , subdomain_data = mf ) # Define the Neumann boundary condition for the traction vector n = FacetNormal ( mesh ) traction = dot ( sigma ( u ), n ) # Integrate to get the traction vector reaction = assemble ( traction [ 1 ] * ds ( 1 )) return reaction from dolfin import * from matplotlib import pyplot as plt # Create mesh and define function space length , depth = 3000 , 300 num_ele_along_depth = 10 ele_size = depth / num_ele_along_depth mesh = RectangleMesh ( Point ( 0 , 0 ), Point ( length , depth ), int ( length / ele_size ), int ( depth / ele_size )) V = VectorFunctionSpace ( mesh , \"Lagrange\" , 1 ) # Mark boundary subdomians clamped_boundary = CompiledSubDomain ( \"near(x[0],0)\" ) disp_boundary = CompiledSubDomain ( \"near(x[0],3000)\" ) # Define Dirichlet boundary (x = 0 or x = 1) fixed = Expression (( \"0.0\" , \"0.0\" ), degree = 1 ) disp = Expression (( \"-disp_step*t\" ), disp_step = 100 , t = 1 , degree = 1 ) bcl = DirichletBC ( V , fixed , clamped_boundary ) bcr = DirichletBC ( V . sub ( 1 ), disp , disp_boundary ) bcs = [ bcl , bcr ] # Define functions du = TrialFunction ( V ) # Incremental displacement v = TestFunction ( V ) # Test function u = Function ( V ) # Displacement from previous iteration B = Constant (( 0.0 , 0.0 )) # Body force per unit volume T = Constant (( 0.0 , 0.0 )) # Traction force on the boundary # Kinematics d = u . geometric_dimension () I = Identity ( d ) # Identity tensor F = I + grad ( u ) # Deformation gradient C = F . T * F # Right Cauchy-Green tensor # Invariants of deformation tensors Ic = tr ( C ) J = det ( F ) # Elasticity parameters E , nu = 1 , 0.45 mu , lmbda = Constant ( E / ( 2 * ( 1 + nu ))), Constant ( E * nu / (( 1 + nu ) * ( 1 - 2 * nu ))) # Stored strain energy density (compressible neo-Hookean model) psi = ( mu / 2 ) * ( Ic - 3 ) - mu * ln ( J ) + ( lmbda / 2 ) * ( ln ( J )) ** 2 # Total potential energy Pi = psi * dx - dot ( B , u ) * dx - dot ( T , u ) * ds # Compute first variation of Pi (directional derivative about u in the direction of v) F = derivative ( Pi , u , v ) # Compute Jacobian of F J = derivative ( F , u , du ) # Compute solution problem = NonlinearVariationalProblem ( F , u , bcs , J ) solver = NonlinearVariationalSolver ( problem ) prm = solver . parameters prm [ 'newton_solver' ][ 'absolute_tolerance' ] = 1E-7 prm [ 'newton_solver' ][ 'relative_tolerance' ] = 1E-7 prm [ 'newton_solver' ][ 'maximum_iterations' ] = 1000 prm [ 'newton_solver' ][ 'linear_solver' ] = 'gmres' prm [ 'newton_solver' ][ 'preconditioner' ] = 'hypre_euclid' prm [ 'newton_solver' ][ 'krylov_solver' ][ 'absolute_tolerance' ] = 1E-7 prm [ 'newton_solver' ][ 'krylov_solver' ][ 'relative_tolerance' ] = 1E-7 prm [ 'newton_solver' ][ 'krylov_solver' ][ 'maximum_iterations' ] = 1000 reaction_force = [] displacement = [] for t in range ( 0 , 30 ): disp . t = t solver . solve () displacement . append ( disp . t * 100 ) reaction_force . append ( get_reaction_force ( mesh )) plt . figure ( figsize = ( 8 , 8 )) plt . plot ( displacement , reaction_force ) [<matplotlib.lines.Line2D at 0x7f3c7917b940>] plt . figure ( figsize = ( 18 , 16 )) # Plot solution scale_factor = 1 / 10 plot ( u * scale_factor , title = 'Displacement' , mode = 'displacement' ) <matplotlib.collections.PolyCollection at 0x7f3c78fc6390>","title":"Pseudo-time analysis"},{"location":"2_notebooks/day-5/exercises/1_bi_metallic_quasi_static/","text":"Exercise: Bimetallic Quasi-Static Thermal Simulation using Steel and Brass Unit Square using FEniCS In this exercise, you will perform a bimetallic quasi-static thermal simulation using the Finite Element Method (FEM) with FEniCS. The simulation will involve a unit square made of two different materials: steel and brass. The goal is to analyze the steady-state temperature distribution within the square and observe the thermal behavior at the interface of the two materials. | Materials: The following table provides the material properties for steel and brass: Material Thermal Conductivity (k) [W/mK] Specific Heat Capacity (Cp) [J/kgK] Density (\u03c1) [kg/m\u00b3] Steel 50.2 486.0 7850 Brass 109.0 377.0 8520 Task: Geometry and Mesh Generation: Create a unit square with side length L = 1.0 units (you can choose any unit system). Divide the square into a suitable number of elements to create a mesh. You can start with a relatively coarse mesh and later refine it to observe its effect on the simulation results. Setting up the Problem: Define the governing equation for steady-state heat conduction in 2D. The equation involves the Laplace operator and accounts for the material properties. Implement appropriate boundary conditions for the simulation. Specify the temperature boundary condition for all four sides of the unit square. You can use Dirichlet boundary conditions, where you set the temperature values at the boundaries. Material Properties: Use the provided material properties for steel and brass. Thermal Simulation: Assemble the finite element problem using FEniCS and solve the system of equations to obtain the temperature distribution within the unit square. Perform the simulation for different time steps to observe the quasi-static behavior of the system. You can use a small time step for better accuracy. Post-Processing and Analysis: Visualize the temperature distribution using contour plots or color maps. Analyze the temperature distribution at the interface between steel and brass. Observe if there are any significant temperature gradients or discontinuities at this interface. Mesh Refinement: Re-run the simulation with a refined mesh (i.e., more elements) and compare the results with the coarser mesh. Discuss the differences and the effect of mesh refinement on the accuracy of the simulation. Discussion and Conclusion: Write a summary of your findings, including observations about the temperature distribution, behavior at the interface of the two materials, and the influence of mesh refinement on the simulation results.","title":"1_bi_metallic_quasi_static.md"},{"location":"2_notebooks/day-5/exercises/2_thermo_mechanical_transient/","text":"Thermo-Mechanical Transient Simulation using FEniCS Objective: The objective of this exercise is to perform a thermo-mechanical transient simulation using the FEniCS finite element library. In this exercise, we will explore the coupling between thermal and mechanical phenomena in a time-dependent setting. The problem involves a 2D domain, and we will consider a linear elastic material model. Problem Description: Consider a 2D square domain \u03a9 with dimensions LxL, where L = 1.0 m. The domain is initially at room temperature T_initial = 25\u00b0C. At t = 0, the left boundary (x = 0) is subjected to a temperature of T_boundary = 100\u00b0C, while the right boundary (x = L) is maintained at T_boundary = 50\u00b0C. The top (y = L) and bottom (y = 0) boundaries are assumed to be insulated, i.e., there is no heat flux through these boundaries. The material properties are given in the following table: Property Symbol Value Young's modulus E 210e9 Pa Poisson's ratio \u03bd 0.3 Thermal expansion \u03b1 1.2e-5 1/\u00b0C Conductivity k 50 W/(m\u00b0C) Density \u03c1 7800 kg/m\u00b3 Specific heat c 480 J/(kg\u00b0C) Tasks: 1. Set up the 2D square domain \u03a9 and define appropriate mesh resolution. 2. Implement a function to compute the temperature distribution within the domain over time using the heat equation. 3. Implement a function to compute the displacement field within the domain over time using the linear elasticity equations. 4. Perform a transient simulation, coupling the heat equation and linear elasticity equations, to obtain the temperature and displacement fields at different time steps. 5. Visualize the temperature and displacement fields at various time steps using appropriate visualization tools. 6. Analyze the results and observe the temperature and displacement evolution within the domain over time. Boundary Conditions: - Initial condition: T(x, y, 0) = T_initial for all points (x, y) within \u03a9. - Left boundary condition: T(x = 0, y, t) = T_boundary for all y and t > 0. - Right boundary condition: T(x = L, y, t) = T_boundary for all y and t > 0. - Top and bottom boundary conditions: \u2202T/\u2202y = 0 (insulated boundaries) for all x, t > 0. - Displacement boundary conditions: u(x = 0, y, t) = 0 for all y and t > 0 (fixed boundary). Note: For the simulation, you can use an appropriate time-stepping scheme (e.g., Forward Euler, Backward Euler, or Crank-Nicolson) and consider suitable time intervals to observe the transient behavior effectively. You may also choose the finite element degree and other numerical parameters based on your understanding and computational resources. Remember to interpret and analyze the results in light of the thermo-mechanical coupling and transient behavior exhibited by the system.","title":"2_thermo_mechanical_transient.md"},{"location":"2_notebooks/day-5/tutorials/1_thermoelasticity/","text":"Linear thermoelasticity The temperature field is uncoupled from the mechanical fields whereas the latter depend on the temperature due to presence of thermal strains in the thermoelastic constitutive relation. This situation can be described as weak thermomechanical coupling. Problem position We consider the case of a rectangular 2D domain of dimensions \\(L\\times H\\) fully clamped on both lateral sides and the bottom side is subjected to a uniform temperature increase of \\(\\Delta T = +50^{\\circ}C\\) while the top and lateral boundaries remain at the initial temperature \\(T_0\\) . The geometry and boundary regions are first defined. from dolfin import * from mshr import * import matplotlib.pyplot as plt % matplotlib inline L , H = 5 , 3 mesh = RectangleMesh ( Point ( 0. , 0. ), Point ( L , H ), 100 , 10 , \"crossed\" ) def lateral_sides ( x , on_boundary ): return ( near ( x [ 0 ], 0 ) or near ( x [ 0 ], L )) and on_boundary def bottom ( x , on_boundary ): return near ( x [ 1 ], 0 ) and on_boundary def top ( x , on_boundary ): return near ( x [ 1 ], H ) and on_boundary Because of the weak coupling discussed before, the thermal and mechanical problem can be solved separately. As a result, we don't need to resort to Mixed FunctionSpaces but can just define separately both problems. The temperature is solution to the following equation \\( \\(\\text{div}(k\\nabla T) = 0\\) \\) where \\(k\\) is the thermal conductivity (here we have no heat source). Since \\(k\\) is assumed to be homogeneous, it will not influence the solution. We therefore obtain a standard Poisson equation without forcing terms. Its formulation and resolution in FEniCS is quite standard with the temperature variation \\(\\Delta T\\) as the main unknown. VT = FunctionSpace ( mesh , \"CG\" , 1 ) T_ , dT = TestFunction ( VT ), TrialFunction ( VT ) Delta_T = Function ( VT , name = \"Temperature increase\" ) aT = dot ( grad ( dT ), grad ( T_ )) * dx LT = Constant ( 0 ) * T_ * dx bcT = [ DirichletBC ( VT , Constant ( 50. ), bottom ), DirichletBC ( VT , Constant ( 0. ), top ), DirichletBC ( VT , Constant ( 0. ), lateral_sides )] solve ( aT == LT , Delta_T , bcT ) plt . figure ( figsize = ( 18 , 8 )) p = plot ( Delta_T ) plt . colorbar ( p ) plt . show () Mecanical problem The linearized thermoelastic constitutive equation is given by: \\[\\begin{equation} \\boldsymbol{\\sigma} = \\mathbb{C}:(\\boldsymbol{\\varepsilon}-\\alpha(T-T_0)\\boldsymbol{1}) = \\lambda\\text{tr}(\\boldsymbol{\\varepsilon})\\boldsymbol{1}+2\\mu\\boldsymbol{\\varepsilon} -\\alpha(3\\lambda+2\\mu)(T-T_0)\\boldsymbol{1} \\end{equation}\\] where \\(\\lambda,\\mu\\) are the Lam\u00e9 parameters and \\(\\alpha\\) is the thermal expansion coefficient. As regards the current problem, the last term corresponding to the thermal strains is completely known. The following formulation can thus be generalized to any kind of known initial stress or eigenstrain state such as pre-stress or phase changes. E = Constant ( 50e3 ) nu = Constant ( 0.2 ) mu = E / 2 / ( 1 + nu ) lmbda = E * nu / ( 1 + nu ) / ( 1 - 2 * nu ) alpha = Constant ( 1e-5 ) f = Constant (( 0 , 0 )) def eps ( v ): return sym ( grad ( v )) def sigma ( v , dT ): return ( lmbda * tr ( eps ( v )) - alpha * ( 3 * lmbda + 2 * mu ) * dT ) * Identity ( 2 ) + 2.0 * mu * eps ( v ) Vu = VectorFunctionSpace ( mesh , 'CG' , 2 ) du = TrialFunction ( Vu ) u_ = TestFunction ( Vu ) Wint = inner ( sigma ( du , Delta_T ), eps ( u_ )) * dx aM = lhs ( Wint ) LM = rhs ( Wint ) + inner ( f , u_ ) * dx bcu = DirichletBC ( Vu , Constant (( 0. , 0. )), lateral_sides ) u = Function ( Vu , name = \"Displacement\" ) First, the self-weight loading is deactivated, only thermal stresses are computed. solve ( aM == LM , u , bcu ) plt . figure ( figsize = ( 18 , 8 )) p = plot ( 1e3 * u [ 1 ], title = \"Vertical displacement [mm]\" ) plt . colorbar ( p ) plt . show () plt . figure ( figsize = ( 18 , 8 )) p = plot ( sigma ( u , Delta_T )[ 0 , 0 ], title = \"Horizontal stress [MPa]\" ) plt . colorbar ( p ) plt . show ()","title":"1_thermoelasticity.md"},{"location":"2_notebooks/day-5/tutorials/1_thermoelasticity/#linear-thermoelasticity","text":"The temperature field is uncoupled from the mechanical fields whereas the latter depend on the temperature due to presence of thermal strains in the thermoelastic constitutive relation. This situation can be described as weak thermomechanical coupling.","title":"Linear thermoelasticity"},{"location":"2_notebooks/day-5/tutorials/1_thermoelasticity/#problem-position","text":"We consider the case of a rectangular 2D domain of dimensions \\(L\\times H\\) fully clamped on both lateral sides and the bottom side is subjected to a uniform temperature increase of \\(\\Delta T = +50^{\\circ}C\\) while the top and lateral boundaries remain at the initial temperature \\(T_0\\) . The geometry and boundary regions are first defined. from dolfin import * from mshr import * import matplotlib.pyplot as plt % matplotlib inline L , H = 5 , 3 mesh = RectangleMesh ( Point ( 0. , 0. ), Point ( L , H ), 100 , 10 , \"crossed\" ) def lateral_sides ( x , on_boundary ): return ( near ( x [ 0 ], 0 ) or near ( x [ 0 ], L )) and on_boundary def bottom ( x , on_boundary ): return near ( x [ 1 ], 0 ) and on_boundary def top ( x , on_boundary ): return near ( x [ 1 ], H ) and on_boundary Because of the weak coupling discussed before, the thermal and mechanical problem can be solved separately. As a result, we don't need to resort to Mixed FunctionSpaces but can just define separately both problems. The temperature is solution to the following equation \\( \\(\\text{div}(k\\nabla T) = 0\\) \\) where \\(k\\) is the thermal conductivity (here we have no heat source). Since \\(k\\) is assumed to be homogeneous, it will not influence the solution. We therefore obtain a standard Poisson equation without forcing terms. Its formulation and resolution in FEniCS is quite standard with the temperature variation \\(\\Delta T\\) as the main unknown. VT = FunctionSpace ( mesh , \"CG\" , 1 ) T_ , dT = TestFunction ( VT ), TrialFunction ( VT ) Delta_T = Function ( VT , name = \"Temperature increase\" ) aT = dot ( grad ( dT ), grad ( T_ )) * dx LT = Constant ( 0 ) * T_ * dx bcT = [ DirichletBC ( VT , Constant ( 50. ), bottom ), DirichletBC ( VT , Constant ( 0. ), top ), DirichletBC ( VT , Constant ( 0. ), lateral_sides )] solve ( aT == LT , Delta_T , bcT ) plt . figure ( figsize = ( 18 , 8 )) p = plot ( Delta_T ) plt . colorbar ( p ) plt . show ()","title":"Problem position"},{"location":"2_notebooks/day-5/tutorials/1_thermoelasticity/#mecanical-problem","text":"The linearized thermoelastic constitutive equation is given by: \\[\\begin{equation} \\boldsymbol{\\sigma} = \\mathbb{C}:(\\boldsymbol{\\varepsilon}-\\alpha(T-T_0)\\boldsymbol{1}) = \\lambda\\text{tr}(\\boldsymbol{\\varepsilon})\\boldsymbol{1}+2\\mu\\boldsymbol{\\varepsilon} -\\alpha(3\\lambda+2\\mu)(T-T_0)\\boldsymbol{1} \\end{equation}\\] where \\(\\lambda,\\mu\\) are the Lam\u00e9 parameters and \\(\\alpha\\) is the thermal expansion coefficient. As regards the current problem, the last term corresponding to the thermal strains is completely known. The following formulation can thus be generalized to any kind of known initial stress or eigenstrain state such as pre-stress or phase changes. E = Constant ( 50e3 ) nu = Constant ( 0.2 ) mu = E / 2 / ( 1 + nu ) lmbda = E * nu / ( 1 + nu ) / ( 1 - 2 * nu ) alpha = Constant ( 1e-5 ) f = Constant (( 0 , 0 )) def eps ( v ): return sym ( grad ( v )) def sigma ( v , dT ): return ( lmbda * tr ( eps ( v )) - alpha * ( 3 * lmbda + 2 * mu ) * dT ) * Identity ( 2 ) + 2.0 * mu * eps ( v ) Vu = VectorFunctionSpace ( mesh , 'CG' , 2 ) du = TrialFunction ( Vu ) u_ = TestFunction ( Vu ) Wint = inner ( sigma ( du , Delta_T ), eps ( u_ )) * dx aM = lhs ( Wint ) LM = rhs ( Wint ) + inner ( f , u_ ) * dx bcu = DirichletBC ( Vu , Constant (( 0. , 0. )), lateral_sides ) u = Function ( Vu , name = \"Displacement\" ) First, the self-weight loading is deactivated, only thermal stresses are computed. solve ( aM == LM , u , bcu ) plt . figure ( figsize = ( 18 , 8 )) p = plot ( 1e3 * u [ 1 ], title = \"Vertical displacement [mm]\" ) plt . colorbar ( p ) plt . show () plt . figure ( figsize = ( 18 , 8 )) p = plot ( sigma ( u , Delta_T )[ 0 , 0 ], title = \"Horizontal stress [MPa]\" ) plt . colorbar ( p ) plt . show ()","title":"Mecanical problem"},{"location":"2_notebooks/day-5/tutorials/2_multi_material/","text":"from dolfin import * from matplotlib import pyplot as plt length , depth = 1300 , 300 num_ele_along_depth = 10 ele_size = depth / num_ele_along_depth mesh = RectangleMesh ( Point ( 0 , 0 ), Point ( length , depth ), int ( length / ele_size ), int ( depth / ele_size )) How to assign material properties to different subdomains? Assigning material properties to different domains is a common task in finite element simulations using FEniCS. FEniCS provides a flexible way to handle complex geometries and define material properties on different regions of the mesh. To achieve this, we can use a MeshFunction to label different subdomains and then use Measures to integrate over these labeled subdomains. mat_1_sub_domain = CompiledSubDomain ( \"x[1]<=D/2\" , D = depth ) mat_2_sub_domain = CompiledSubDomain ( \"x[1]>=D/2\" , D = depth ) dim = mesh . topology () . dim () mf = MeshFunction ( \"size_t\" , mesh , dim ) mat_1 = 1 mat_2 = 2 mat_1_sub_domain . mark ( mf , mat_1 ) mat_2_sub_domain . mark ( mf , mat_2 ) plot ( mf ) <matplotlib.collections.PolyCollection at 0x7f67110faf28> Define the Material Properties Now, define the material properties for each domain. For this example, we'll consider two materials (material 1 and material 2): mat_prop = { 1 : { \"E\" : 1.0 , \"nu\" : 0.30 , \"rho\" : 5e-8 }, 2 : { \"E\" : 2.0 , \"nu\" : 0.25 , \"rho\" : 10e-8 } } g = 9.81 def epsilon ( u ): return 0.5 * ( grad ( u ) + grad ( u ) . T ) def sigma ( u , mat_prop ): E , nu = mat_prop [ 'E' ], mat_prop [ 'nu' ] lmbda = ( E * nu ) / (( 1 + nu ) * ( 1 - 2 * nu )) mu = E / ( 2 * ( 1 + nu )) return lmbda * tr ( epsilon ( u )) * Identity ( dim ) + 2 * mu * epsilon ( u ) # Define variational problem U = VectorFunctionSpace ( mesh , \"CG\" , 1 ) u , v = TrialFunction ( U ), TestFunction ( U ) dx = Measure ( \"dx\" , subdomain_data = mf ) a = inner ( sigma ( u , mat_prop [ mat_1 ]), epsilon ( v )) * dx ( mat_1 ) + \\ inner ( sigma ( u , mat_prop [ mat_2 ]), epsilon ( v )) * dx ( mat_2 ) L = dot ( Constant (( 0 , - mat_prop [ mat_1 ][ 'rho' ] * g )), v ) * dx ( mat_1 ) + \\ dot ( Constant (( 0 , - mat_prop [ mat_2 ][ 'rho' ] * g )), v ) * dx ( mat_2 ) clamped_boundary = CompiledSubDomain ( \"near(x[0],0)\" ) bc = DirichletBC ( U , Constant (( 0 ,) * dim ), clamped_boundary ) # Compute solution u_sol = Function ( U ) solve ( a == L , u_sol , bc ) plt . figure ( figsize = ( 18 , 16 )) # Plot solution scale_factor = 3 plot ( u_sol * scale_factor , title = 'Displacement' , mode = 'displacement' ) Calling FFC just-in-time (JIT) compiler, this may take some time. <matplotlib.collections.PolyCollection at 0x7f6711583240>","title":"2_multi_material.md"},{"location":"2_notebooks/day-5/tutorials/2_multi_material/#how-to-assign-material-properties-to-different-subdomains","text":"Assigning material properties to different domains is a common task in finite element simulations using FEniCS. FEniCS provides a flexible way to handle complex geometries and define material properties on different regions of the mesh. To achieve this, we can use a MeshFunction to label different subdomains and then use Measures to integrate over these labeled subdomains. mat_1_sub_domain = CompiledSubDomain ( \"x[1]<=D/2\" , D = depth ) mat_2_sub_domain = CompiledSubDomain ( \"x[1]>=D/2\" , D = depth ) dim = mesh . topology () . dim () mf = MeshFunction ( \"size_t\" , mesh , dim ) mat_1 = 1 mat_2 = 2 mat_1_sub_domain . mark ( mf , mat_1 ) mat_2_sub_domain . mark ( mf , mat_2 ) plot ( mf ) <matplotlib.collections.PolyCollection at 0x7f67110faf28>","title":"How to assign material properties to different subdomains?"},{"location":"2_notebooks/day-5/tutorials/2_multi_material/#define-the-material-properties","text":"Now, define the material properties for each domain. For this example, we'll consider two materials (material 1 and material 2): mat_prop = { 1 : { \"E\" : 1.0 , \"nu\" : 0.30 , \"rho\" : 5e-8 }, 2 : { \"E\" : 2.0 , \"nu\" : 0.25 , \"rho\" : 10e-8 } } g = 9.81 def epsilon ( u ): return 0.5 * ( grad ( u ) + grad ( u ) . T ) def sigma ( u , mat_prop ): E , nu = mat_prop [ 'E' ], mat_prop [ 'nu' ] lmbda = ( E * nu ) / (( 1 + nu ) * ( 1 - 2 * nu )) mu = E / ( 2 * ( 1 + nu )) return lmbda * tr ( epsilon ( u )) * Identity ( dim ) + 2 * mu * epsilon ( u ) # Define variational problem U = VectorFunctionSpace ( mesh , \"CG\" , 1 ) u , v = TrialFunction ( U ), TestFunction ( U ) dx = Measure ( \"dx\" , subdomain_data = mf ) a = inner ( sigma ( u , mat_prop [ mat_1 ]), epsilon ( v )) * dx ( mat_1 ) + \\ inner ( sigma ( u , mat_prop [ mat_2 ]), epsilon ( v )) * dx ( mat_2 ) L = dot ( Constant (( 0 , - mat_prop [ mat_1 ][ 'rho' ] * g )), v ) * dx ( mat_1 ) + \\ dot ( Constant (( 0 , - mat_prop [ mat_2 ][ 'rho' ] * g )), v ) * dx ( mat_2 ) clamped_boundary = CompiledSubDomain ( \"near(x[0],0)\" ) bc = DirichletBC ( U , Constant (( 0 ,) * dim ), clamped_boundary ) # Compute solution u_sol = Function ( U ) solve ( a == L , u_sol , bc ) plt . figure ( figsize = ( 18 , 16 )) # Plot solution scale_factor = 3 plot ( u_sol * scale_factor , title = 'Displacement' , mode = 'displacement' ) Calling FFC just-in-time (JIT) compiler, this may take some time. <matplotlib.collections.PolyCollection at 0x7f6711583240>","title":"Define the Material Properties"},{"location":"2_notebooks/day-5/tutorials/3_transient_analysis/","text":"Heat equation The heat equation is a fundamental partial differential equation that describes the evolution of temperature distribution over time in a given domain. In this tutorial, we will perform a 1D transient analysis of the heat equation. The 1D heat equation is given by: \\[ \\frac{\\partial u}{\\partial t} = k \\frac{\\partial^2 u}{\\partial x^2} + f(x, t), \\] where \\(u(x, t)\\) is the temperature distribution at position \\(x\\) and time \\(t\\) , \\(k\\) is the thermal conductivity, and \\(f(x, t)\\) represents any source term in the equation. For this analysis, we consider a 1D domain \\([0, L]\\) . https://fenicsproject.org/pub/tutorial/html/._ftut1006.html from fenics import * # Create a mesh L = 1.0 # Length of the domain nx = 100 # Number of spatial nodes mesh = IntervalMesh ( nx , 0 , L ) # Define the function space degree = 1 # Linear elements S = FunctionSpace ( mesh , 'CG' , degree ) Initial Condition and Boundary Conditions We specify an initial temperature distribution \\(u_{\\text{initial}}(x)\\) at \\(t = 0\\) . For this analysis, we use the expression \\(u_{\\text{initial}}(x) = \\exp(-100(x - 0.5)^2)\\) . Additionally, we need to impose boundary conditions to complete the problem formulation. # Define initial condition and boundary conditions u_initial = Expression ( '20*sin(pi*x[0])' , degree = 2 , domain = mesh ) u_n = interpolate ( u_initial , S ) u_n_minus_1 = Function ( S ) Temporal Discretization We define the total simulation time \\(T\\) and the number of time steps \\(num\\_steps\\) . The time step size \\(dt\\) is calculated as \\(dt = \\frac{T}{num\\_steps}\\) . # Define time discretization parameters T = 1.0 # Total simulation time num_steps = 5 # Number of time steps dt = T / num_steps # Time step size # Define the heat equation u = TrialFunction ( S ) v = TestFunction ( S ) k = Constant ( 1.0e-1 ) # Thermal conductivity f = Constant ( 0.0 ) # Source term (zero for this example) support = CompiledSubDomain ( \"on_boundary\" ) # bc = DirichletBC(S, Constant(0), support) bc = [] a = u * v * dx + dt * k * inner ( grad ( u ), grad ( v )) * dx L = ( u_n * v * dx + dt * f * v * dx ) Time-stepping Loop We use a time-stepping loop to iteratively solve the heat equation at each time step. At every time step, we update the temperature distribution based on the discretized equation. u = Function ( S ) t = 0 # Create a figure with the specified size fig , ax = plt . subplots ( figsize = ( 13 , 8 )) label = 'time: {0:3.1f} ' . format ( t ) # Label for each curve ax . plot ( mesh . coordinates (), u_n . vector ()[:], label = label , linewidth = 3 ) for n in range ( num_steps ): t += dt solve ( a == L , u , bc ) # Update solution for the next time step u_n_minus_1 . assign ( u_n ) u_n . assign ( u ) label = 'time: {0:3.1f} ' . format ( t ) # Label for each curve ax . plot ( mesh . coordinates (), u . vector ()[:], label = label , linewidth = 3 ) # Add labels and legend ax . set_xlabel ( 'x' ) ax . set_ylabel ( 'Temperature' ) ax . legend () # Show the plot ax . grid ( True ) plt . show ()","title":"3_transient_analysis.md"},{"location":"2_notebooks/day-5/tutorials/3_transient_analysis/#heat-equation","text":"The heat equation is a fundamental partial differential equation that describes the evolution of temperature distribution over time in a given domain. In this tutorial, we will perform a 1D transient analysis of the heat equation. The 1D heat equation is given by: \\[ \\frac{\\partial u}{\\partial t} = k \\frac{\\partial^2 u}{\\partial x^2} + f(x, t), \\] where \\(u(x, t)\\) is the temperature distribution at position \\(x\\) and time \\(t\\) , \\(k\\) is the thermal conductivity, and \\(f(x, t)\\) represents any source term in the equation. For this analysis, we consider a 1D domain \\([0, L]\\) . https://fenicsproject.org/pub/tutorial/html/._ftut1006.html from fenics import * # Create a mesh L = 1.0 # Length of the domain nx = 100 # Number of spatial nodes mesh = IntervalMesh ( nx , 0 , L ) # Define the function space degree = 1 # Linear elements S = FunctionSpace ( mesh , 'CG' , degree )","title":"Heat equation"},{"location":"2_notebooks/day-5/tutorials/3_transient_analysis/#initial-condition-and-boundary-conditions","text":"We specify an initial temperature distribution \\(u_{\\text{initial}}(x)\\) at \\(t = 0\\) . For this analysis, we use the expression \\(u_{\\text{initial}}(x) = \\exp(-100(x - 0.5)^2)\\) . Additionally, we need to impose boundary conditions to complete the problem formulation. # Define initial condition and boundary conditions u_initial = Expression ( '20*sin(pi*x[0])' , degree = 2 , domain = mesh ) u_n = interpolate ( u_initial , S ) u_n_minus_1 = Function ( S )","title":"Initial Condition and Boundary Conditions"},{"location":"2_notebooks/day-5/tutorials/3_transient_analysis/#temporal-discretization","text":"We define the total simulation time \\(T\\) and the number of time steps \\(num\\_steps\\) . The time step size \\(dt\\) is calculated as \\(dt = \\frac{T}{num\\_steps}\\) . # Define time discretization parameters T = 1.0 # Total simulation time num_steps = 5 # Number of time steps dt = T / num_steps # Time step size # Define the heat equation u = TrialFunction ( S ) v = TestFunction ( S ) k = Constant ( 1.0e-1 ) # Thermal conductivity f = Constant ( 0.0 ) # Source term (zero for this example) support = CompiledSubDomain ( \"on_boundary\" ) # bc = DirichletBC(S, Constant(0), support) bc = [] a = u * v * dx + dt * k * inner ( grad ( u ), grad ( v )) * dx L = ( u_n * v * dx + dt * f * v * dx )","title":"Temporal Discretization"},{"location":"2_notebooks/day-5/tutorials/3_transient_analysis/#time-stepping-loop","text":"We use a time-stepping loop to iteratively solve the heat equation at each time step. At every time step, we update the temperature distribution based on the discretized equation. u = Function ( S ) t = 0 # Create a figure with the specified size fig , ax = plt . subplots ( figsize = ( 13 , 8 )) label = 'time: {0:3.1f} ' . format ( t ) # Label for each curve ax . plot ( mesh . coordinates (), u_n . vector ()[:], label = label , linewidth = 3 ) for n in range ( num_steps ): t += dt solve ( a == L , u , bc ) # Update solution for the next time step u_n_minus_1 . assign ( u_n ) u_n . assign ( u ) label = 'time: {0:3.1f} ' . format ( t ) # Label for each curve ax . plot ( mesh . coordinates (), u . vector ()[:], label = label , linewidth = 3 ) # Add labels and legend ax . set_xlabel ( 'x' ) ax . set_ylabel ( 'Temperature' ) ax . legend () # Show the plot ax . grid ( True ) plt . show ()","title":"Time-stepping Loop"}]}